{"version":3,"sources":["icons3 sync /^/.//.*/.svg$","icons3/clear_sky_day.svg","icons3/clear_sky_night.svg","icons3/cloudy.svg","icons3/fog.svg","icons3/half_clear_sky_day.svg","icons3/half_clear_sky_night.svg","icons3/heavy_rain.svg","icons3/heavy_sleet.svg","icons3/light_rain.svg","icons3/light_sleet.svg","icons3/moderate_rain.svg","icons3/moderate_sleet.svg","icons3/nearly_clear_sky_day.svg","icons3/nearly_clear_sky_night.svg","icons3/overcast.svg","icons3/snow.svg","icons3/thunder.svg","icons3/unknown.svg","components/atoms/Paper/index.tsx","components/weather/WeatherCell/index.tsx","components/weather/TimeCell/index.tsx","components/weather/WeatherTable/index.tsx","components/weather/WeatherTableList/index.tsx","location/geocoder.ts","store/locationSearch/types.ts","location/geolocation.ts","store/locationSearch/actions.ts","weather/types.ts","components/location/LocationSearchItem/index.tsx","store/forecasts/types.ts","helpers/date.ts","weather/weatherProviders/abstractProvider.ts","weather/weatherProviders/MET.ts","weather/weatherProviders/SMHI.ts","weather/index.ts","store/forecasts/actions.ts","components/location/LocationSearchList/index.tsx","components/location/LocationSearch/index.tsx","components/pages/WeatherPage/index.tsx","App.tsx","serviceWorker.ts","store/locationSearch/reducers.ts","store/forecasts/reducers.ts","store/index.ts","index.tsx"],"names":["map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","module","exports","Paper","props","className","style","children","Text","Typography","WeatherCell","undefined","weather","Fragment","strong","Math","round","temperature","symbol","alt","src","require","default","type","wind","precipitation","precipitationUnit","TimeCell","time","Title","WeatherTable","level","this","name","width","height","providers","ignored","index","provider","margin","overflowX","justifyContent","justifyRight","tableData","column","formatTime","React","Component","any","date","getHours","slice","startDate","endDate","WeatherTableList","result","getDay","isLoading","size","fontWeight","fontSize","selectedLocation","forecast","hours","getTableName","days","weatherDay","spans","connect","lastSearch","state","forecasts","locationSearch","lastSearchId","startGeocode","searchTerm","listener","trimmed","trim","onSuccess","newSearchId","setTimeout","tryPerformSearch","isOutdated","searchId","fetchGeocodeData","a","process","fetch","formatData","json","locations","loc","push","country","lat","Number","long","ok","console","warn","statusText","onAbort","SELECT_LOCATION","SELECT_USER_LOCATION","GEOCODE_START","GEOCODE_SUCCESS","GEOCODE_FAILURE","LOCATE_USER_START","LOCATE_USER_SUCCESS","LOCATE_USER_FAILURE","startGeolocate","navigator","geolocation","getCurrentPosition","position","geocodeCoordinates","coords","error","altitude","altitudeAccuracy","latitude","longitude","accuracy","heading","speed","coordinates","fetchReverseGeocode","response","onError","data","NaN","display_name","address","city","municipality","county","lon","geocodeFailure","errorMessage","locateUserSuccess","location","WeatherIcon","Item","onClick","onSelect","FORECAST_FETCH_START","FORECAST_FETCH_SUCCESS","FORECAST_FETCH_FAILURE","listHoursFromNow","count","start","Date","setHours","setMinutes","setSeconds","setMilliseconds","listDates","listDaysFromTomorrow","setDate","getDate","interval","times","i","getTime","AbstractProvider","onFailure","requestData","toString","fillForecast","MET","icons","heavy_rain","light_rain","moderate_rain","clear_sky_day","nearly_clear_sky_day","half_clear_sky_day","cloudy","fog","snow","heavy_sleet","light_sleet","moderate_sleet","icon","clear_sky_night","half_clear_sky_night","nearly_clear_sky_night","status","timeSeries","properties","timeseries","log","hoursIndex","timeSeriesIndex","length","timeSerie","timeSerieDate","symbol_str","next_1_hours","summary","symbol_code","details","precipitation_amount","next_6_hours","next_12_hours","toNight","unknown","instant","air_temperature","wind_speed","day","j","span","spanLength","minTemp","maxTemp","air_temperature_min","air_temperature_max","nextTimeSerie","pThis","pNext","min","max","temperatureMax","temperatureMin","gust","wind_speed_of_gust","SMHI","thunder","value","substr","validTime","parameters","find","values","getIcon","iconDate","sumWeather","startIndex","symbolDate","totalPrecipitation","maxWind","maxGust","symbols","temp","isNaN","maxSymbolCount","maxSymbol","symbolCount","weatherProviders","newForecast","callback","createEmptyForecast","remaining","message","forEach","fetchForecast","now","createEmptyCombinedWeather","year","getUTCFullYear","month","getUTCMonth","getUTCDate","UTC","listProviderNames","combined","searchSuccess","searchFailure","fetchForecasts","dispatch","LocationSearchList","selectLocation","locationResults","LocationSearchItem","onLocationSelect","geocodeResults","LocationSearch","text","searchLocations","autoFocus","allowClear","prefix","SearchOutlined","onChange","target","close","geocodeIsLoading","searchString","results","WeatherPage","showLocationSearch","findUserPosition","selectUserLocation","setState","overflow","ghost","shape","openLocationSearch","closeLocationSearch","App","Boolean","window","hostname","match","initialState","geocodeErrorMessage","userLocation","userLocationIsLoading","userLocationErrorMessage","rootReducer","combineReducers","action","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","applyMiddleware","thunk","ReactDOM","render","store","document","getElementById","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.081051a4.chunk.js","sourcesContent":["var map = {\n\t\"./clear_sky_day.svg\": 195,\n\t\"./clear_sky_night.svg\": 196,\n\t\"./cloudy.svg\": 197,\n\t\"./fog.svg\": 198,\n\t\"./half_clear_sky_day.svg\": 199,\n\t\"./half_clear_sky_night.svg\": 200,\n\t\"./heavy_rain.svg\": 201,\n\t\"./heavy_sleet.svg\": 202,\n\t\"./light_rain.svg\": 203,\n\t\"./light_sleet.svg\": 204,\n\t\"./moderate_rain.svg\": 205,\n\t\"./moderate_sleet.svg\": 206,\n\t\"./nearly_clear_sky_day.svg\": 207,\n\t\"./nearly_clear_sky_night.svg\": 208,\n\t\"./overcast.svg\": 209,\n\t\"./snow.svg\": 210,\n\t\"./thunder.svg\": 211,\n\t\"./unknown.svg\": 212\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 194;","export default __webpack_public_path__ + \"static/media/clear_sky_day.08d2252c.svg\";","export default __webpack_public_path__ + \"static/media/clear_sky_night.fe72ba7f.svg\";","export default __webpack_public_path__ + \"static/media/cloudy.b1731609.svg\";","export default __webpack_public_path__ + \"static/media/fog.fdf19a8b.svg\";","export default __webpack_public_path__ + \"static/media/half_clear_sky_day.89d8c1b7.svg\";","export default __webpack_public_path__ + \"static/media/half_clear_sky_night.8d02af80.svg\";","export default __webpack_public_path__ + \"static/media/heavy_rain.b7a3ac6c.svg\";","export default __webpack_public_path__ + \"static/media/heavy_sleet.52c71e8e.svg\";","export default __webpack_public_path__ + \"static/media/light_rain.5dcd949e.svg\";","export default __webpack_public_path__ + \"static/media/light_sleet.a7670194.svg\";","export default __webpack_public_path__ + \"static/media/moderate_rain.5ca1b602.svg\";","export default __webpack_public_path__ + \"static/media/moderate_sleet.73193cce.svg\";","export default __webpack_public_path__ + \"static/media/nearly_clear_sky_day.36e650c9.svg\";","export default __webpack_public_path__ + \"static/media/nearly_clear_sky_night.5d46915e.svg\";","export default __webpack_public_path__ + \"static/media/overcast.a2822c8c.svg\";","export default __webpack_public_path__ + \"static/media/snow.9758315a.svg\";","export default __webpack_public_path__ + \"static/media/thunder.31fc6f06.svg\";","export default __webpack_public_path__ + \"static/media/unknown.c0e76eeb.svg\";","import React from \"react\";\nimport CSS from 'csstype'\n\nimport './style.css';\n\ninterface Props {\n    style?: CSS.Properties,\n    children?: React.ReactNode\n}\n\nconst Paper = (props: Props) => (\n    <div className=\"paper\" style={props.style}>\n        {props.children}\n    </div>\n);\n\nexport default Paper;","import React from \"react\";\nimport { Typography } from \"antd\";\n\nimport './style.css';\nimport { IWeather } from \"../../../weather/types\";\n\nconst { Text } = Typography;\n\ninterface Props {\n    weather: IWeather\n}\n\nconst WeatherCell = (props: Props) => (\n    <div className=\"weather_cell\">\n        {props.weather !== undefined &&\n            <React.Fragment>\n                <Text strong>{Math.round(props.weather.temperature)} °C</Text>\n                {props.weather.symbol &&\n                    <img className='weather_symbol' alt=\"\" /* TODO: Add alt prop! */ src={require(\"../../../icons3/\" + props.weather.symbol + \".svg\").default} />\n                }\n                <div>\n                    <Text type=\"secondary\">{Math.round(props.weather.wind) + \" m/s\"}</Text>\n                    <br/>\n                    <Text type=\"secondary\"> {props.weather.precipitation + \" \" + props.weather.precipitationUnit}</Text>\n                </div>\n            </React.Fragment>\n        }\n    </div>\n);\n\n\nexport default WeatherCell;","import React from \"react\";\nimport { Typography } from \"antd\";\n\nimport './style.css';\n\nconst { Text } = Typography;\n\ninterface Props {\n    time: string\n}\n\nconst TimeCell = (props: Props) => (\n    <div className=\"time_cell\">\n        <Text strong>{props.time}</Text>\n    </div>\n);\n\nexport default TimeCell;","import React from \"react\";\nimport Paper from \"../../atoms/Paper\";\nimport WeatherCell from \"../WeatherCell\";\nimport { Divider, Typography } from \"antd\";\nimport TimeCell from \"../TimeCell\";\nimport { IWeatherPoint, IWeatherSpan } from \"../../../weather/types\";\nimport './style.css';\n\nconst { Title } = Typography;\n\ninterface IWeatherTableListProps {\n    tableData: IWeatherSpan[] | IWeatherPoint[],\n    providers: string[],\n    name: string,\n    justifyRight: boolean, // This is not used and can be removed\n}\n\nclass WeatherTable extends React.Component<IWeatherTableListProps> {\n    public render() {\n        return (\n            <div>\n                <Title level={4}>{this.props.name}</Title>\n                <div className=\"columns\">\n\n                    {/* Time row background */}\n                    <div className=\"right-column\">\n                        <div className=\"time-row\" style={{ width: '100%' }}>\n                            <Paper style={{ width: '100%', height: '100%' }} />\n                        </div>\n                    </div>\n\n                    {/* Weather row background. One for each provider. */}\n                    <div className=\"all-columns\">\n                        <div className=\"time-row\" />\n                        {this.props.providers.map((ignored, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Paper style={{ width: '100%', height: '100%' }} />\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Provider Name */}\n                    <div className=\"left-column\">\n                        <div className=\"time-row\" />\n                        {this.props.providers.map((provider, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Typography className=\"weather-provider-name\">\n                                    {provider}\n                                </Typography>\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Divider */}\n                    <div className=\"divider-column\">\n                        <div className=\"time-row\" />\n                        {this.props.providers.map((ignored, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Divider type=\"vertical\" style={{ height: 'calc(100% - 5px)', margin: 0 }} />\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Time cells and Weather cells */}\n                    <div className=\"right-column\" style={{ overflowX: 'auto' }}>\n                        <div className=\"time-row\" style={{ justifyContent: this.props.justifyRight ? \"flex-end\" : \"space-around\" }}>\n                            {this.props.tableData.map((column: any, index) =>\n                                <TimeCell key={index} time={formatTime(column)} />\n                            )}\n                        </div>\n                        {this.props.providers.map((provider, index) =>\n                            <div key={index} className=\"weather-row\" style={{ justifyContent: this.props.justifyRight ? \"flex-end\" : \"space-around\" }}>\n                                {this.props.tableData.map((column, index) =>\n                                    <WeatherCell key={index} weather={column.weather[provider]} />\n                                )}\n                            </div>\n                        )}\n                    </div>\n                </div >\n            </div>\n        );\n    }\n}\n\nfunction formatTime(column: IWeatherPoint | IWeatherSpan): string {\n    const any: any = column;\n    if (any.date) {\n        return ('0' + any.date.getHours()).slice(-2);\n    }\n    else if (any.startDate && any.endDate) {\n        return ('0' + any.startDate.getHours()).slice(-2) + \"—\" + ('0' + any.endDate.getHours()).slice(-2);\n    }\n\n    return \"\";\n}\n\nexport default WeatherTable;","import React from \"react\";\nimport './style.css';\nimport WeatherTable from \"../WeatherTable\";\nimport { Spin, Typography } from \"antd\";\nimport { AppState } from \"../../../store\";\nimport { connect } from \"react-redux\";\nimport { ILocation } from \"../../../location/types\";\nimport { IWeatherForecast } from \"../../../weather/types\";\nimport { requestUserPosition } from \"../../../store/locationSearch/actions\";\n\nconst { Title } = Typography;\n\ninterface IWeatherTableListProps {\n    forecast: IWeatherForecast,\n    isLoading: boolean,\n    selectedLocation?: ILocation,\n}\n\nclass WeatherTableList extends React.Component<IWeatherTableListProps> {\n    private getTableName(index: number, date: Date | undefined): string {\n        let result = \"\";\n\n        if (!date) return result;\n\n        if (index === 0) {\n            result = \"Idag, \";\n        } else {\n            result = \"\";\n        }\n\n        switch (date.getDay()) {\n            case 1:\n                result += \"Måndag\";\n                break;\n            case 2:\n                result += \"Tisdag\";\n                break;\n            case 3:\n                result += \"Onsdag\";\n                break;\n            case 4:\n                result += \"Torsdag\";\n                break;\n            case 5:\n                result += \"Fredag\";\n                break;\n            case 6:\n                result += \"Lördag\";\n                break;\n            case 0:\n                result += \"Söndag\";\n                break;\n        }\n\n        return result;\n    }\n\n    public render() {\n        return (\n            <div className=\"list\">\n                {this.props.isLoading ?\n                    <Spin className=\"spin\" size=\"large\" />\n                    :\n                    <React.Fragment>\n                        <Title className=\"title\"  style={{fontWeight: 1, fontSize: 50}}>{this.props.selectedLocation?.name}</Title>\n                        <div className=\"items\">\n                            <WeatherTable tableData={this.props.forecast.hours} providers={this.props.forecast.providers} justifyRight={false} name={this.getTableName(0, this.props.forecast.hours[0].date)} />\n                            {this.props.forecast.days.map((weatherDay, index) =>\n                                <WeatherTable key={index} tableData={weatherDay.spans} providers={this.props.forecast.providers} justifyRight={false} name={this.getTableName(index + 1, weatherDay.spans[0].startDate)} />\n                            )}\n                        </div>\n                    </React.Fragment>\n                }\n            </div>\n        );\n    }\n}\n\n\nfunction mapStateToProps(state: AppState) {\n    return {\n        forecast: state.forecasts.forecast,\n        isLoading: state.forecasts.isLoading,\n        selectedLocation: state.locationSearch.selectedLocation,\n    }\n}\n\nexport default connect(mapStateToProps)(WeatherTableList);\n","import { ILocation, IGeocodeListener } from \"./types\";\n\nlet lastSearch: string;\nlet lastSearchId: number = 0;\n\n// The minimum delay between requests to the api\nconst MIN_SEARCH_DELAY: number = 500;\n\n\n/**\n * Starts a new geocode search. The result will be returned to the listener.\n */\nexport function startGeocode(searchTerm: string, listener: IGeocodeListener): void {\n    const trimmed = searchTerm.trim()\n    if (trimmed === lastSearch) {\n        return;\n    }\n\n    lastSearch = trimmed;\n\n    if (trimmed === \"\") {\n        // Don't do an actual search if there is no search term\n        listener.onSuccess([]);\n        lastSearchId++;\n        return;\n    }\n\n    lastSearchId++;\n    let newSearchId = lastSearchId;\n\n    setTimeout(() => tryPerformSearch(newSearchId, trimmed, listener), MIN_SEARCH_DELAY);\n}\n\n\n/**\n * Returns true if the given search id is outdated.\n */\nfunction isOutdated(searchId: number): boolean {\n    return searchId !== lastSearchId;\n}\n\n\n/**\n * Fetches data from geocode api.\n */\nasync function fetchGeocodeData(searchTerm: string): Promise<Response> {\n    const key = process.env.REACT_APP_LOCATIONIQ;\n    const address = \"https://api.locationiq.com/v1/autocomplete.php\";\n\n    return fetch(`${address}?key=${key}&q=${searchTerm}&viewbox=3,44,32,71&limit=20&dedupe=1&accept-language=sv`);//&accept-language=native');\n}\n\n\n/**\n * Formats the json data from the geocode api.\n */\nfunction formatData(json: any): ILocation[] {\n    const locations: ILocation[] = []\n\n    for (const loc of json) {\n        locations.push({\n            country: loc['display_address'],\n            name: loc['display_place'],\n            lat: Number(loc['lat']),\n            long: Number(loc['lon']),\n            alt: 0,\n        });\n    }\n\n    return locations\n}\n\n\n/**\n * Tries to perform a search, but cancels if the search becomes outdated.\n */\nasync function tryPerformSearch(searchId: number, searchTerm: string, listener: IGeocodeListener) {\n    if (isOutdated(searchId)) {\n        return;\n    }\n\n    const result = await fetchGeocodeData(searchTerm);\n\n    if (isOutdated(searchId)) {\n        return;\n    }\n\n    const json = await result.json();\n\n    if (isOutdated(searchId)) {\n        return;\n    }\n\n    if (result.ok) {\n        const locations = formatData(json);\n        listener.onSuccess(locations);\n    }\n    // Returns this with a 404 status when no location found.\n    else if ( json['error'] === \"Unable to geocode\" ) {\n        const locations: ILocation[] = [];\n        listener.onSuccess(locations);\n    }\n    else {\n        // TODO: Remove console warn\n        console.warn('Geocode response error!', result.statusText);\n        listener.onAbort();\n    }\n}\n","import { ILocation } from \"../../location/types\";\n\nexport interface ILocationSearchState {\n    selectedLocation?: ILocation,\n\n    geocodeResults: ILocation[],\n    geocodeIsLoading: boolean,\n    geocodeErrorMessage: string,\n\n    userLocation?: ILocation,\n    userLocationIsLoading: boolean,\n    userLocationErrorMessage: string,\n}\n\n// Select location\n\nexport const SELECT_LOCATION = 'SELECT_LOCATION';\n\ninterface ISelectLocationAction {\n    type: typeof SELECT_LOCATION,\n    location: ILocation\n}\n\nexport const SELECT_USER_LOCATION = \"SELECT_USER_LOCATION\";\n\ninterface ISelectUserLocation {\n    type: typeof SELECT_USER_LOCATION,\n}\n\n// Geocode\n\nexport const GEOCODE_START = 'GEOCODE_START';\n\ninterface IGeocodeStartAction {\n    type: typeof GEOCODE_START,\n}\n\nexport const GEOCODE_SUCCESS = 'GEOCODE_SUCCESS';\n\ninterface IGeocodeSuccessAction {\n    type: typeof GEOCODE_SUCCESS,\n    results: ILocation[]\n}\n\nexport const GEOCODE_FAILURE = 'GEOCODE_FAILURE';\n\ninterface IGeocodeFailureAction {\n    type: typeof GEOCODE_FAILURE,\n    errorMessage: string\n}\n\n// Locate user\n\nexport const LOCATE_USER_START = 'LOCATE_USER_START';\n\ninterface ILocateUserStartAction {\n    type: typeof LOCATE_USER_START,\n}\n\nexport const LOCATE_USER_SUCCESS = 'LOCATE_USER_SUCCESS';\n\ninterface ILocateUserSuccessAction {\n    type: typeof LOCATE_USER_SUCCESS,\n    location: ILocation\n}\n\nexport const LOCATE_USER_FAILURE = 'LOCATE_USER_FAILURE';\n\ninterface ILocateUserFailureAction {\n    type: typeof LOCATE_USER_FAILURE,\n    errorMessage: string\n}\n\n// Types\n\nexport type LocationActionTypes = ISelectLocationAction | ISelectUserLocation | IGeocodeStartAction | IGeocodeSuccessAction | IGeocodeFailureAction | ILocateUserStartAction | ILocateUserSuccessAction | ILocateUserFailureAction;","\nimport { ILocation, IUserPositionListener } from \"./types\";\n\n/**\n * Tries to find the users position and returns it to the listener.\n */\nexport function startGeolocate(listener: IUserPositionListener) {\n    const successCallback: PositionCallback = (position) => geocodeCoordinates(position.coords, listener);\n\n    const errorCallback: PositionErrorCallback = (error) => {\n        const coords: GeolocationCoordinates = {\n            altitude: 10,\n            altitudeAccuracy: 0,\n            latitude: 59.33066,\n            longitude: 18.06855,\n            accuracy: 0,\n            heading: null,\n            speed: 0,\n        };\n        geocodeCoordinates(coords, listener);\n    };\n\n    navigator.geolocation.getCurrentPosition(successCallback, errorCallback);\n}\n\n/**\n * Converts coordinates to a location\n */\nasync function geocodeCoordinates(coordinates: GeolocationCoordinates, listener: IUserPositionListener) {\n    const response = await fetchReverseGeocode(coordinates.latitude, coordinates.longitude);\n\n    if (!response.ok) {\n        listener.onError();\n        return;\n    }\n\n    const json = await response.json();\n\n    let data = formatData(json);\n    // Geocoder does not have altitude so use user position.\n    data.alt = coordinates.altitude || NaN;\n\n    listener.onSuccess(data)\n}\n\n/**\n * Fetches data from reverse geocoding api.\n */\nasync function fetchReverseGeocode(latitude: number, longitude: number): Promise<Response> {\n    const key = process.env.REACT_APP_LOCATIONIQ;\n    const address = \"https://eu1.locationiq.com/v1/reverse.php\";\n\n    return fetch(`${address}?key=${key}&lat=${latitude}&lon=${longitude}&format=json&accept-language=sv`);\n}\n\n/**\n * Formats the json data from the reverse geocoding api.\n */\nfunction formatData(json: any): ILocation {\n    return {\n        country: json.display_name,\n        name: json.address.city || json.address.municipality || json.address.county || json.address.country,\n        lat: json.lat,\n        long: json.lon,\n        alt: NaN,\n    }\n}\n","import { Dispatch } from 'redux';\nimport { IGeocodeListener, ILocation, IUserPositionListener as ILocateUserListener } from '../../location/types';\nimport { startGeocode } from '../../location/geocoder';\nimport { GEOCODE_FAILURE, GEOCODE_START, GEOCODE_SUCCESS, LOCATE_USER_FAILURE, LOCATE_USER_START, LOCATE_USER_SUCCESS, LocationActionTypes, SELECT_LOCATION, SELECT_USER_LOCATION } from './types';\nimport { startGeolocate } from '../../location/geolocation';\nimport { fetchForecasts } from '../forecasts/actions';\n\n\nexport function selectLocation(location: ILocation) {\n    return {\n        type: SELECT_LOCATION,\n        location: location,\n    }\n}\n\nexport function selectUserLocation() {\n    return {\n        type: SELECT_USER_LOCATION,\n    }\n}\n\nexport const geocode = (searchString: string) => async (dispatch: Dispatch) => {\n    const onSuccess = (locations: ILocation[]) => dispatch(geocodeSuccess(locations));\n    const onFailure = () => dispatch(geocodeFailure(\"\")); // TODO: Error message\n\n    const listener: IGeocodeListener = {\n        onSuccess: onSuccess,\n        onAbort: onFailure,\n    }\n\n    dispatch(geocodeStart());\n\n    startGeocode(searchString, listener);\n}\n\nexport const requestUserPosition = (callback?: (location: ILocation) => void) => async (dispatch: Dispatch) => {\n    const onSuccess = (location: ILocation) => {\n        dispatch(locateUserSuccess(location));\n        if (callback)\n            callback(location);\n    };\n    const onError = () => dispatch(geocodeFailure(\"\")); // TODO: Error message\n\n    const listener: ILocateUserListener = {\n        onSuccess: onSuccess,\n        onError: onError,\n    }\n\n    dispatch(locateUserStart());\n\n    startGeolocate(listener)\n}\n\nfunction geocodeStart(): LocationActionTypes {\n    return {\n        type: GEOCODE_START,\n    };\n}\n\nfunction geocodeSuccess(results: ILocation[]): LocationActionTypes {\n    return {\n        type: GEOCODE_SUCCESS,\n        results: results\n    }\n}\n\nfunction geocodeFailure(errorMessage: string): LocationActionTypes {\n    return {\n        type: GEOCODE_FAILURE,\n        errorMessage: errorMessage\n    }\n}\n\nfunction locateUserStart(): LocationActionTypes {\n    return {\n        type: LOCATE_USER_START,\n    };\n}\n\nfunction locateUserSuccess(location: ILocation): LocationActionTypes {\n    return {\n        type: LOCATE_USER_SUCCESS,\n        location: location\n    }\n}\n\nfunction locateUserFailure(errorMessage: string): LocationActionTypes {\n    return {\n        type: LOCATE_USER_FAILURE,\n        errorMessage: errorMessage\n    }\n}","import { ILocation } from \"../location/types\";\n\nexport interface IWeatherForecast {\n    hours: IWeatherPoint[],\n    days: IWeatherDay[],\n    providers: string[],\n    location: ILocation,\n}\n\nexport interface IWeatherPoint {\n    date: Date,\n    weather: ICombinedWeather,\n}\n\nexport interface IWeatherDay {\n    spans: IWeatherSpan[],\n}\n\nexport interface IWeatherSpan {\n    startDate: Date,\n    endDate: Date,\n    weather: ICombinedWeather\n}\n\nexport interface ICombinedWeather {\n    [key: string]: IWeather,\n}\n\nexport interface IWeather {\n    temperature: number,\n    temperatureMin: number,\n    temperatureMax: number,\n    wind: number,\n    gust: number,\n    precipitation: number,\n    precipitationUnit: string,\n    symbol: WeatherIcon,\n}\n\nexport enum WeatherIcon {\n    unknown = \"unknown\",\n    // Cloudiness\n    clear_sky_day = \"clear_sky_day\",\n    clear_sky_night = \"clear_sky_night\",\n    nearly_clear_sky_day = \"nearly_clear_sky_day\",\n    nearly_clear_sky_night = \"nearly_clear_sky_night\",\n    half_clear_sky_day = \"half_clear_sky_day\",\n    half_clear_sky_night = \"half_clear_sky_night\",\n    cloudy = \"cloudy\",\n    // Rain\n    light_rain = \"light_rain\",\n    moderate_rain = \"moderate_rain\",\n    heavy_rain = \"heavy_rain\",\n    // Sleet\n    light_sleet = \"light_sleet\",\n    moderate_sleet = \"moderate_sleet\",\n    heavy_sleet = \"heavy_sleet\",\n    // Other\n    snow = \"snow\",\n    thunder = \"thunder\",\n    fog = \"fog\",\n}","import { Typography } from \"antd\";\nimport { ILocation } from \"../../../location/types\";\nimport './style.css';\n\nconst { Text } = Typography;\n\ninterface Props {\n    location: ILocation,\n    onSelect: (location: ILocation) => void,\n}\n\nconst Item = (props: Props) => (\n    <button className=\"location-list-item\" onClick={() => props.onSelect(props.location)}>\n        <Text strong>{props.location.name}</Text>\n        <Text type=\"secondary\">{props.location.country}</Text>\n    </button>\n);\n\nexport default Item;","import { IWeatherForecast } from \"../../weather/types\";\n\nexport interface IWeatherState {\n    forecast: IWeatherForecast,\n    isLoading: boolean\n    errorMessage?: string,\n}\n\nexport const FORECAST_FETCH_START = 'FORECAST_FETCH_START';\n\ninterface IFetchStartAction {\n    type: typeof FORECAST_FETCH_START,\n}\n\nexport const FORECAST_FETCH_SUCCESS = 'FORECAST_FETCH_SUCCESS';\n\ninterface IFetchSuccessAction {\n    type: typeof FORECAST_FETCH_SUCCESS,\n    forecast: IWeatherForecast,\n}\n\nexport const FORECAST_FETCH_FAILURE = 'FORECAST_FETCH_FAILURE';\n\ninterface IFetchFailureAction {\n    type: typeof FORECAST_FETCH_FAILURE,\n    errorMessage: string,\n}\n\nexport type ForecastActionTypes = IFetchStartAction | IFetchSuccessAction | IFetchFailureAction;","/**\n * Returns a list of Date objects with one hour difference, starting with the current hour.\n * @param count The number of Date objects to return.\n */\nexport function listHoursFromNow(count: number): Date[] {\n    let start = new Date();\n    start.setHours(start.getHours() + 1);\n    start.setMinutes(0);\n    start.setSeconds(0);\n    start.setMilliseconds(0);\n    return listDates(start, 3600000, count);\n}\n\n/**\n * Returns a list of Date objects with one day difference, starting with the next day.\n * @param count The number of Date objects to return.\n */\nexport function listDaysFromTomorrow(count: number): Date[] {\n    let start = new Date();\n    start.setDate(start.getDate() + 1);\n    return listDates(start, 86400000, count);\n}\n\n/**\n * Returns an array of Date objects.\n * @param start The first date in the array.\n * @param interval The time difference in milliseconds.\n * @param count The number of Date objects to return.\n */\nexport function listDates(start: Date, interval: number, count: number): Date[] {\n    let times: Date[] = []\n\n    for (let i = 0; i < count; i++) {\n        times.push(new Date(start.getTime() + (i * interval)));\n    }\n\n    return times;\n}\n\n/**\n * Returns the number of days from today to the given date.\n */\nexport function getDayOffset(date: Date) {\n    let today = new Date();\n    today.setHours(0);\n    today.setMinutes(0);\n    today.setSeconds(0);\n    today.setMilliseconds(0);\n\n    let diff = date.getTime() - today.getTime();\n\n    return Math.floor(diff / 86400000);  // 86400000 milliseconds in a day)\n}","import { ILocation } from \"../../location/types\";\nimport { IWeatherForecast } from \"../types\";\n\nexport default abstract class AbstractProvider {\n    name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    public async fetchForecast(forecast: IWeatherForecast, location: ILocation, onSuccess: () => any, onFailure: (error: Error) => any) {\n        try {\n            // Send a request\n            let response = await this.requestData(location.lat.toString(), location.long.toString());\n\n            const json = await response.json();\n\n            // Format the response \n            await this.fillForecast(json, forecast);\n\n        } catch (e: any) {\n            console.error(e)\n            onFailure(e);\n            return;\n        }\n\n        onSuccess()\n    }\n\n    protected abstract requestData(lat: string, long: string): Promise<Response>;\n    protected abstract fillForecast(json: any, forecast: IWeatherForecast): void;\n}","import { IWeatherForecast, WeatherIcon } from \"../types\";\nimport AbstractProvider from \"./abstractProvider\";\n\n\nexport default class MET extends AbstractProvider {\n    constructor() {\n        super(\"Yr\")\n    }\n\n    // Icon list: https://api.met.no/weatherapi/weathericon/2.0/documentation\n    private icons: any = {\n        \"heavyrain\": WeatherIcon.heavy_rain,\n        \"lightrain\": WeatherIcon.light_rain,\n        \"rain\": WeatherIcon.moderate_rain,\n        \"clearsky_day\": WeatherIcon.clear_sky_day,\n        \"clearsky_night\": WeatherIcon.clear_sky_day,\n        \"fair_day\": WeatherIcon.nearly_clear_sky_day,\n        \"fair_night\": WeatherIcon.nearly_clear_sky_day,\n        \"partlycloudy_day\": WeatherIcon.half_clear_sky_day,\n        \"partlycloudy_night\": WeatherIcon.half_clear_sky_day,\n        \"cloudy\": WeatherIcon.cloudy,\n        \"fog\": WeatherIcon.fog,\n        \"heavysnow\": WeatherIcon.snow,\n        \"heavysnowshowers\": WeatherIcon.snow,\n        \"lightsnow\": WeatherIcon.snow,\n        \"lightsnowshowers\": WeatherIcon.snow,\n        \"snow\": WeatherIcon.snow,\n        \"heavysleet\": WeatherIcon.heavy_sleet,\n        \"heavysleetshowers\": WeatherIcon.heavy_sleet,\n        \"lightsleet\": WeatherIcon.light_sleet,\n        \"lightsleetshowers\": WeatherIcon.light_sleet,\n        \"sleet\": WeatherIcon.moderate_sleet,\n        \"sleetshowers\": WeatherIcon.moderate_sleet,\n    }\n\n    private toNight(icon: WeatherIcon, date: Date): WeatherIcon {\n        const hours = date.getHours();\n        if (hours > 15 || hours < 8) {\n            switch (icon) {\n                case WeatherIcon.clear_sky_day:\n                    return WeatherIcon.clear_sky_night;\n                case WeatherIcon.half_clear_sky_day:\n                    return WeatherIcon.half_clear_sky_night;\n                case WeatherIcon.nearly_clear_sky_day:\n                    return WeatherIcon.nearly_clear_sky_night;\n            }\n        }\n        return icon;\n    }\n\n    protected async requestData(lat: string, long: string): Promise<Response> {\n        const result = await fetch('https://api.met.no/weatherapi/locationforecast/2.0/complete?lat='\n            + lat + '&lon=' + long);\n\n        if (!result.ok) {\n            throw new Error(\"Weather response error! status: \" + result.status)\n        }\n\n        return result;\n    }\n\n    protected fillForecast(json: any, forecast: IWeatherForecast): void {\n        const timeSeries: any[] = json.properties.timeseries;\n\n        console.log(\"forecast\", forecast);\n        console.log(\"json\", json);\n\n        // --- Fill hours ---\n        let hoursIndex = 0;\n        let timeSeriesIndex = 0;\n        while (hoursIndex < forecast.hours.length && timeSeriesIndex < timeSeries.length) {\n            const timeSerie: any = timeSeries[timeSeriesIndex];\n            const timeSerieDate: Date = new Date(timeSerie.time);\n\n            // If this time serie is to old\n            if (forecast.hours[hoursIndex].date < timeSerieDate) {\n                hoursIndex++;\n                continue;\n            }\n            // If this time serie is not old enough\n            if (forecast.hours[hoursIndex].date > timeSerieDate) {\n                timeSeriesIndex++;\n                continue;\n            }\n\n            let weather = forecast.hours[hoursIndex].weather[this.name];\n\n            let symbol_str: string;\n            let precipitation: number;\n            if (timeSerie.data.next_1_hours) {\n                symbol_str = timeSerie.data.next_1_hours.summary.symbol_code;\n                precipitation = timeSerie.data.next_1_hours.details.precipitation_amount;\n            }\n            else if (timeSerie.data.next_6_hours) {\n                symbol_str = timeSerie.data.next_6_hours.summary.symbol_code;\n                precipitation = timeSerie.data.next_6_hours.details.precipitation_amount;\n            }\n            else if (timeSerie.data.next_12_hours) {\n                symbol_str = timeSerie.data.next_12_hours.summary.symbol_code;\n                precipitation = timeSerie.data.next_12_hours.details.precipitation_amount;\n            }\n            else {\n                continue;\n            }\n\n            const symbol = this.toNight(this.icons[symbol_str] || WeatherIcon.unknown, timeSerieDate);\n            if (symbol === WeatherIcon.unknown) {\n                console.warn(\"Unknown symbol\", symbol_str)\n            }\n\n            weather.temperature = timeSerie.data.instant.details.air_temperature;\n            weather.wind = timeSerie.data.instant.details.wind_speed;\n            weather.precipitation = precipitation;\n            weather.precipitationUnit = \"mm\";\n            weather.symbol = symbol;\n\n            timeSeriesIndex++;\n            hoursIndex++;\n        }\n\n        // --- Fill days ---\n        timeSeriesIndex = 0;\n        for (let i = 0; i < forecast.days.length; i++) {\n            const day = forecast.days[i];\n            for (let j = 0; j < day.spans.length; j++) {\n\n                if (timeSeriesIndex >= timeSeries.length) {\n                    console.log(\"break\");\n                    break;\n                }\n\n                const span = day.spans[j];\n                const timeSerie = timeSeries[timeSeriesIndex];\n                const timeSerieDate: Date = new Date(timeSerie.time);\n\n                console.log(\"span\", j, span);\n\n                // If this time serie is to old\n                if (span.startDate < timeSerieDate) {\n                    continue;\n                }\n                // If this time serie is not old enough\n                if (span.startDate > timeSerieDate) {\n                    timeSeriesIndex++;\n                    j--;\n                    continue;\n                }\n\n                let weather = span.weather[this.name];\n\n                // Get span length in hours\n                const spanLength = (span.endDate.getTime() - span.startDate.getTime()) / (1000 * 60 * 60);\n\n                let symbol_str: string;\n                let precipitation: number;\n                let minTemp: number;\n                let maxTemp: number;\n                if (spanLength === 6) {\n                    symbol_str = timeSerie.data.next_6_hours.summary.symbol_code;\n                    precipitation = timeSerie.data.next_6_hours.details.precipitation_amount;\n                    minTemp = timeSerie.data.next_6_hours.details.air_temperature_min;\n                    maxTemp = timeSerie.data.next_6_hours.details.air_temperature_max;\n                }\n                else if (spanLength === 12) {\n                    const nextTimeSerie = timeSeries[timeSeriesIndex + 1];\n\n                    symbol_str = timeSerie.data.next_12_hours.summary.symbol_code;\n\n                    const pThis = timeSerie.data.next_6_hours.details.precipitation_amount;\n                    const pNext = nextTimeSerie.data.next_6_hours.details.precipitation_amount;\n\n                    precipitation = Math.round(10 * ((pThis + pNext) / 12)) / 10;\n\n                    minTemp = Math.min(timeSerie.data.next_6_hours.details.air_temperature_min, nextTimeSerie.data.next_6_hours.details.air_temperature_min);\n                    maxTemp = Math.max(timeSerie.data.next_6_hours.details.air_temperature_max, nextTimeSerie.data.next_6_hours.details.air_temperature_max);\n                }\n                else {\n                    console.warn(\"Unknown span length\", spanLength)\n                    timeSeriesIndex++;\n                    continue;\n                }\n\n                const symbol = this.toNight(this.icons[symbol_str] || WeatherIcon.unknown, timeSerieDate);\n                if (symbol === WeatherIcon.unknown) {\n                    console.warn(\"Unknown symbol\", symbol_str)\n                }\n\n                weather.temperature = (maxTemp + minTemp) / 2;\n                weather.temperatureMax = maxTemp;\n                weather.temperatureMin = minTemp;\n                weather.wind = timeSerie.data.instant.details.wind_speed; // TODO: Find max wind speed\n                weather.gust = timeSerie.data.instant.details.wind_speed_of_gust; // TODO: Find max gust speed\n                weather.precipitation = precipitation;\n                weather.precipitationUnit = \"mm/h\";\n                weather.symbol = symbol;\n\n                timeSeriesIndex++;\n            }\n        }\n    }\n}","import { time } from \"console\";\nimport { isReturnStatement } from \"typescript\";\nimport { IWeather, IWeatherForecast, WeatherIcon } from \"../types\";\nimport AbstractProvider from \"./abstractProvider\";\n\n\nexport default class SMHI extends AbstractProvider {\n    constructor() {\n        super(\"SMHI\")\n    }\n\n    // Weather parameter descriptions can be found at:\n    // https://opendata.smhi.se/apidocs/metfcst/parameters.html#parameter-table\n    private icons = {\n        1: WeatherIcon.clear_sky_day,        // Clear sky\n        2: WeatherIcon.nearly_clear_sky_day, // Nearly clear sky\n        3: WeatherIcon.half_clear_sky_day,   // Variable cloudiness\n        4: WeatherIcon.half_clear_sky_day,   // Half clear sky\n        5: WeatherIcon.cloudy,           // Cloudy sky\n        6: WeatherIcon.cloudy,           // Overcast\n        7: WeatherIcon.fog,                  // Fo7\n        8: WeatherIcon.light_rain,           // Light rain showers\n        9: WeatherIcon.moderate_rain,        // Moderate rain showers\n        10: WeatherIcon.heavy_rain,          // Heavy rain showers\n        11: WeatherIcon.thunder,             // Thunderstorm\n        18: WeatherIcon.light_rain,          // Light rain\n        19: WeatherIcon.moderate_rain,       // Moderate rain\n        20: WeatherIcon.heavy_rain,          // Heavy rain\n        21: WeatherIcon.thunder,             // Thunder\n        22: WeatherIcon.light_sleet,         // Light sleet\n        23: WeatherIcon.moderate_sleet,      // Moderate sleet\n        24: WeatherIcon.heavy_sleet,         // Heavy sleet\n        25: WeatherIcon.snow,                // Light snowfall\n        26: WeatherIcon.snow,                // Moderate snowfall\n        27: WeatherIcon.snow,                // Heavy snowfall\n    }\n\n    private getIcon(value: never, date: Date): WeatherIcon {\n        let icon = this.icons[value];\n        if (!icon) {\n            console.warn(\"Unknown symbol value\", value)\n            return WeatherIcon.unknown;\n        }\n\n        const hours = date.getHours();\n        if (hours > 15 || hours < 8) {\n            switch (icon) {\n                case WeatherIcon.clear_sky_day:\n                    return WeatherIcon.clear_sky_night;\n                case WeatherIcon.half_clear_sky_day:\n                    return WeatherIcon.half_clear_sky_night;\n                case WeatherIcon.nearly_clear_sky_day:\n                    return WeatherIcon.nearly_clear_sky_night;\n            }\n        }\n\n        return icon;\n    }\n\n    protected async requestData(lat: string, long: string): Promise<Response> {\n        const max = 9; // the maximum precision allowed by the api (including decimal point)\n        const result = await fetch('https://opendata-download-metfcst.smhi.se/api/category/pmp3g/version/2/geotype/point/lon/'\n            + long.substr(0, max) + '/lat/' + lat.substr(0, max) + '/data.json');\n\n        if (!result.ok) {\n            throw new Error(\"Weather response error! status: ' + result.status\")\n        }\n\n        return result;\n    }\n\n    protected fillForecast(json: any, forecast: IWeatherForecast): void {\n        const timeSeries: [] = json['timeSeries'];\n\n        const currentDateTime = new Date().getTime();\n\n\n        // --- Fill hours ---\n        let hoursIndex = 0;\n        let timeSeriesIndex = 0;\n        while (hoursIndex < forecast.hours.length && timeSeriesIndex < timeSeries.length) {\n            const timeSerie: any = timeSeries[timeSeriesIndex];\n            const timeSerieDate = new Date(timeSerie.validTime);\n\n            // If this time serie is to old\n            if (forecast.hours[hoursIndex].date < timeSerieDate) {\n                hoursIndex++;\n                continue;\n            }\n            // If this time serie is not old enough\n            if (forecast.hours[hoursIndex].date > timeSerieDate) {\n                timeSeriesIndex++;\n                continue;\n            }\n\n            const parameters: any[] = timeSerie.parameters;\n\n            let weather = forecast.hours[hoursIndex].weather[this.name];\n\n            //fillSingleWeather(parameters, weather);\n\n            weather.temperature = parameters.find(e => e.name === \"t\").values[0];\n            weather.precipitation = parameters.find(e => e.name === \"pmean\").values[0];\n            weather.precipitationUnit = \"mm\";\n            weather.wind = parameters.find(e => e.name === \"ws\").values[0];\n            weather.gust = parameters.find(e => e.name === \"gust\").values[0];\n            weather.symbol = this.getIcon(parameters.find(e => e.name === \"Wsymb2\").values[0] as never, timeSerieDate)\n\n            hoursIndex++;\n            timeSeriesIndex++;\n        }\n\n        // --- Fill days ---\n        timeSeriesIndex = 0;\n        for (let i = 0; i < forecast.days.length; i++) {\n            const day = forecast.days[i];\n            for (let j = 0; j < day.spans.length; j++) {\n\n                const span = day.spans[j];\n                const timeSerie: any = timeSeries[timeSeriesIndex];\n                const timeSerieDate: Date = new Date(timeSerie.validTime);\n\n                // If this time serie is to old\n                if (span.startDate < timeSerieDate) {\n                    continue;\n                }\n                // If this time serie is not old enough\n                if (span.startDate > timeSerieDate) {\n                    timeSeriesIndex++;\n                    j--;\n                    continue;\n                }\n\n                let weather = span.weather[this.name];\n\n                const iconDate = new Date((span.startDate.getTime() + span.endDate.getTime()) / 2);\n\n                timeSeriesIndex = this.sumWeather(timeSeries, timeSeriesIndex, span.endDate, iconDate, weather);\n            }\n        }\n    }\n\n    /**\n     * Sums the weather in a time series from an index up to an end date.\n     * The weather will be added to the given weather object.\n     * The index of the end date will be returned.\n     * @returns Index of the end date.\n     */\n    private sumWeather(timeSeries: any[], startIndex: number, endDate: Date, symbolDate: Date, weather: IWeather): number {\n        let index = startIndex;\n\n        let totalPrecipitation = 0;\n        let minTemp: number = NaN;\n        let maxTemp: number = NaN;\n        let maxWind: number = 0;\n        let maxGust: number = 0;\n        let symbols: { [key: number]: number } = {}\n\n        while (index < timeSeries.length) {\n            const timeSerie = timeSeries[index];\n            const timeSerieDate: Date = new Date(timeSerie.validTime);\n\n            if (timeSerieDate > endDate) {\n                index--\n                break;\n            }\n\n            let a = 0;\n            console.log(!a)\n\n            const parameters: any[] = timeSerie.parameters;\n\n            // Precipitation\n            totalPrecipitation += parameters.find(e => e.name === \"pmean\").values[0];\n\n            // Temperature\n            const temp = parameters.find(e => e.name === \"t\").values[0];\n            if (isNaN(minTemp) || temp < minTemp) {\n                minTemp = temp;\n            }\n            if (isNaN(maxTemp) || temp > maxTemp) {\n                maxTemp = temp;\n            }\n            // Wind\n            const wind = parameters.find(e => e.name === \"ws\").values[0];\n            if (wind > maxWind) {\n                maxWind = wind;\n            }\n            // Gust\n            const gust = parameters.find(e => e.name === \"gust\").values[0];\n            if (gust > maxGust) {\n                maxGust = gust;\n            }\n            //= parameters.find(e => e.name === \"pmean\").values[0];\n            //= parameters.find(e => e.name === \"ws\").values[0];\n            //= parameters.find(e => e.name === \"gust\").values[0];\n            //= this.getIcon(parameters.find(e => e.name === \"Wsymb2\").values[0] as never, timeSerieDate)\n\n            const symbol: number = parameters.find(e => e.name === \"Wsymb2\").values[0];\n            if (symbol in symbols) {\n                symbols[symbol] += 1;\n            } else {\n                symbols[symbol] = 1;\n            }\n\n            index++;\n        }\n\n        const count = index - startIndex + 1;\n\n        weather.precipitation = Math.round(10 * totalPrecipitation / count) / 10;\n        weather.precipitationUnit = \"mm/h\";\n        weather.temperatureMax = maxTemp;\n        weather.temperatureMax = minTemp;\n        weather.temperature = (maxTemp + minTemp) / 2;\n        weather.wind = maxWind;\n        weather.gust = maxGust;\n\n        let maxSymbolCount = 0;\n        let maxSymbol = \"\";\n        for (let symbol in symbols) {\n            const symbolCount = symbols[symbol];\n            if (symbolCount > maxSymbolCount) {\n                maxSymbolCount = symbolCount;\n                maxSymbol = symbol;\n            }\n        }\n\n        weather.symbol = this.getIcon(maxSymbol as never, symbolDate);\n\n        return index;\n    }\n}\n","import { listDaysFromTomorrow, listHoursFromNow } from \"../helpers/date\";\nimport { ILocation } from \"../location/types\";\nimport { ICombinedWeather, IWeather, IWeatherDay, IWeatherForecast, IWeatherPoint, IWeatherSpan, WeatherIcon } from \"./types\";\nimport AbstractProvider from \"./weatherProviders/abstractProvider\";\nimport MET from \"./weatherProviders/MET\";\nimport SMHI from \"./weatherProviders/SMHI\";\n\nconst weatherProviders: AbstractProvider[] = [new SMHI(), new MET()]\n\nexport interface forecastCallback {\n    onSuccess: (forecast: IWeatherForecast) => void,\n    onError: (error: string) => void,\n}\n\nexport function newForecast(location: ILocation, callback: forecastCallback): void {\n    const forecast = createEmptyForecast(location);\n\n    let remaining = weatherProviders.length;\n\n    const onSuccess = () => {\n        remaining--;\n\n        console.log(\"success\", forecast);\n\n        if (remaining === 0) {\n            callback.onSuccess(forecast);\n        }\n    }\n\n    const onError = (error: Error) => {\n        callback.onError(error.message);\n    }\n\n    weatherProviders.forEach(provider => {\n        provider.fetchForecast(forecast, location, onSuccess, onError);\n    });\n}\n\nexport function createEmptyForecast(location?: ILocation): IWeatherForecast {\n    const now = new Date();\n\n    return {\n        hours: createEmptyHours(),\n        days: createEmptyDays(now),\n        providers: listProviderNames(),\n        location: location ? location : { country: \"\", name: \"\", lat: NaN, long: NaN, alt: NaN },\n    };\n}\n\nfunction listProviderNames() {\n    return weatherProviders.map((provider) => { return provider.name });\n}\n\nfunction createEmptyHours(): IWeatherPoint[] {\n    return listHoursFromNow(24).map((date: Date) => {\n        return {\n            date: date,\n            weather: createEmptyCombinedWeather(),\n        }\n    });\n}\n\nfunction createEmptyDays(start: Date): IWeatherDay[] {\n    return listDaysFromTomorrow(8).map((date: Date, index: number) => {\n        console.log(date);\n        let spans: IWeatherSpan[] = []\n        const year = date.getUTCFullYear();\n        const month = date.getUTCMonth();\n        const day = date.getUTCDate();\n        if (index <= 4) {\n            spans = [\n                {\n                    startDate: new Date(Date.UTC(year, month, day, 0)),\n                    endDate: new Date(Date.UTC(year, month, day, 6)),\n                    weather: createEmptyCombinedWeather(),\n                }, {\n                    startDate: new Date(Date.UTC(year, month, day, 6)),\n                    endDate: new Date(Date.UTC(year, month, day, 12)),\n                    weather: createEmptyCombinedWeather(),\n                }, {\n                    startDate: new Date(Date.UTC(year, month, day, 12)),\n                    endDate: new Date(Date.UTC(year, month, day, 18)),\n                    weather: createEmptyCombinedWeather(),\n                }, {\n                    startDate: new Date(Date.UTC(year, month, day, 18)),\n                    endDate: new Date(Date.UTC(year, month, day, 24)),\n                    weather: createEmptyCombinedWeather(),\n                }\n            ]\n        }\n        else {\n            spans = [\n                {\n                    startDate: new Date(Date.UTC(year, month, day, 0)),\n                    endDate: new Date(Date.UTC(year, month, day, 12)),\n                    weather: createEmptyCombinedWeather(),\n                }, {\n                    startDate: new Date(Date.UTC(year, month, day, 12)),\n                    endDate: new Date(Date.UTC(year, month, day, 24)),\n                    weather: createEmptyCombinedWeather(),\n                }\n            ]\n        }\n\n        return {\n            spans: spans,\n        }\n    });\n}\n\nfunction createEmptyCombinedWeather(): ICombinedWeather {\n    let combined: ICombinedWeather = {};\n\n    listProviderNames().forEach(name => {\n        combined[name] = {\n            temperature: NaN,\n            temperatureMax: NaN,\n            temperatureMin: NaN,\n            wind: NaN,\n            gust: NaN,\n            precipitation: NaN,\n            precipitationUnit: \"\",\n            symbol: WeatherIcon.unknown,\n        }\n    });\n\n    return combined;\n}\n","import { ForecastActionTypes, FORECAST_FETCH_START, FORECAST_FETCH_SUCCESS, FORECAST_FETCH_FAILURE } from \"./types\";\nimport { Dispatch } from \"redux\";\nimport { ILocation } from \"../../location/types\";\nimport { forecastCallback, newForecast } from \"../../weather\";\nimport { IWeatherForecast } from \"../../weather/types\";\n\nfunction searchStart(): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_START,\n    }\n}\n\nfunction searchSuccess(forecast: IWeatherForecast): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_SUCCESS,\n        forecast: forecast,\n    }\n}\n\nfunction searchFailure(errorMessage: string): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_FAILURE,\n        errorMessage: errorMessage,\n    }\n}\n\nexport const fetchForecasts = (location: ILocation) => async (dispatch: Dispatch) => {\n    const callback: forecastCallback = {\n        onSuccess: (forecast: IWeatherForecast) => dispatch(searchSuccess(forecast)),\n        onError: (errorMessage: string) => dispatch(searchFailure(errorMessage)),\n    }\n\n    dispatch(searchStart());\n    newForecast(location, callback);\n}\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { selectLocation } from \"../../../store/locationSearch/actions\";\nimport { AppState } from \"../../../store\";\nimport LocationSearchItem from \"../LocationSearchItem\";\nimport { Divider } from \"antd\";\nimport { fetchForecasts } from \"../../../store/forecasts/actions\";\nimport \"./style.css\";\nimport { ILocation } from \"../../../location/types\";\n\ninterface ILocationSearchListProps {\n    selectLocation: (location: ILocation) => void,\n    fetchForecasts: (location: ILocation) => void,\n    onSelect: () => void,\n    locationResults: ILocation[],\n    selectedLocation?: ILocation,\n}\n\nclass LocationSearchList extends React.Component<ILocationSearchListProps>{\n\n    private onLocationSelect(location: ILocation): void {\n        // Select location and fetch forecast if it is a new location\n        if (location.country !== this.props.selectedLocation?.country) {\n            this.props.selectLocation(location);\n            this.props.fetchForecasts(location);\n        }\n        this.props.onSelect();\n    }\n\n    render() {\n        return (\n            <div className=\"location-list\">\n                {this.props.locationResults.map((location, index) =>\n                    <React.Fragment key={index}>\n                        <LocationSearchItem location={location} onSelect={location => this.onLocationSelect(location)} />\n                        <Divider style={{ margin: 0 }} />\n                    </React.Fragment>\n                )}\n            </div>\n        );\n    }\n}\n\nfunction mapStateToProps(state: AppState) {\n    return {\n        locationResults: state.locationSearch.geocodeResults,\n        selectedLocation: state.locationSearch.selectedLocation,\n    }\n}\n\nfunction mapDispatchToProps(dispatch: any) { // TODO: Fix any type\n    return {\n        selectLocation: (location: ILocation) => dispatch(selectLocation(location)),\n        fetchForecasts: (location: ILocation) => dispatch(fetchForecasts(location)),\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(LocationSearchList);","import { Button, Input, Spin } from \"antd\";\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport { SearchOutlined } from '@ant-design/icons';\nimport { AppState } from \"../../../store\";\nimport LocationSearchList from \"../LocationSearchList\";\nimport './style.css';\nimport { geocode } from \"../../../store/locationSearch/actions\";\n\ninterface ILocationSearchProps {\n    searchLocations: (searchTerm: string) => void,\n    isLoading: boolean,\n    close: () => void,\n}\n\nclass LocationSearch extends React.Component<ILocationSearchProps>{\n    private onChange(text: string) {\n        this.props.searchLocations(text);\n    }\n\n    render() {\n        return (\n            <div className=\"search\">\n                <div className=\"search-bar\">\n                    <Input size=\"large\" autoFocus allowClear prefix={<SearchOutlined />} onChange={value => this.onChange(value.target.value)} />\n                    <Button size=\"large\" onClick={() => this.props.close()}>Avbryt</Button>\n                </div>\n                {this.props.isLoading ?\n                    <Spin className=\"location-search-spin\" />\n                    :\n                    <LocationSearchList onSelect={() => this.props.close()} />\n                }\n            </div>\n        );\n    }\n}\n\nfunction mapStateToProps(state: AppState) {\n    return {\n        isLoading: state.locationSearch.geocodeIsLoading,\n    }\n}\n\n\nfunction mapDispatchToProps(dispatch: any) { // TODO: Fix any type\n    return {\n        searchLocations: (searchTerm: string) => dispatch(geocode(searchTerm)),\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(LocationSearch);","import React from \"react\";\nimport WeatherTableList from \"../../weather/WeatherTableList\";\nimport LocationSearch from \"../../location/LocationSearch\";\nimport { Button } from 'antd';\nimport { SearchOutlined } from '@ant-design/icons';\nimport './style.css';\nimport { connect } from \"react-redux\";\nimport { requestUserPosition, selectLocation, selectUserLocation } from \"../../../store/locationSearch/actions\";\nimport { AppState } from \"../../../store\";\nimport { ILocation } from \"../../../location/types\";\nimport { fetchForecasts } from \"../../../store/forecasts/actions\";\n\n\ninterface IWeatherPageProps {\n    findUserPosition: (onSuccess?: (location: ILocation) => void) => void,\n    selectUserLocation: () => void,\n    fetchForecasts: (location: ILocation) => void,\n}\n\ninterface IWeatherPageState {\n    showLocationSearch: boolean,\n}\n\nclass WeatherPage extends React.Component<IWeatherPageProps, IWeatherPageState>{\n    constructor(props: Readonly<IWeatherPageProps>) {\n        super(props)\n\n        this.state = {\n            showLocationSearch: false,\n        }\n    }\n\n    componentDidMount() {\n        // Find user position, select it as location, and fetch the forecast\n        const onSuccess = (location: ILocation) => {\n            this.props.selectUserLocation();\n            this.props.fetchForecasts(location);\n        };\n        this.props.findUserPosition(onSuccess);\n    }\n\n    private openLocationSearch() {\n        this.setState({\n            showLocationSearch: true,\n        })\n    }\n\n    private closeLocationSearch() {\n        this.setState({\n            showLocationSearch: false,\n        });\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                {/* Background */}\n                <div id=\"background\" />\n\n                <div className=\"weather-page\" style={{ height: 0, overflow: this.state.showLocationSearch ? 'hidden' : 'unset' }}>\n                    <Button className=\"search-location-button\" ghost icon={<SearchOutlined />} shape=\"circle\" size=\"large\" onClick={() => this.openLocationSearch()} />\n                    <WeatherTableList />\n                </div>\n\n                {this.state.showLocationSearch &&\n                    <LocationSearch close={() => this.closeLocationSearch()} />\n                }\n\n            </React.Fragment>\n        );\n    }\n}\n\nfunction mapStateToProps(state: AppState) {\n    return {\n    }\n}\n\n\nfunction mapDispatchToProps(dispatch: any) { // TODO: Fix any type\n    return {\n        findUserPosition: (onSuccess: any) => dispatch(requestUserPosition(onSuccess)),\n        selectUserLocation: () => dispatch(selectUserLocation()),\n        fetchForecasts: (location: ILocation) => dispatch(fetchForecasts(location)),\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(WeatherPage);\n","import './App.css';\nimport WeatherPage from './components/pages/WeatherPage';\n\nfunction App() {\n  return (\n    <div id=\"app\">\n      <div id=\"page\">\n        <WeatherPage />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { selectLocation } from \"./actions\";\nimport { GEOCODE_FAILURE, GEOCODE_START, GEOCODE_SUCCESS, ILocationSearchState, LOCATE_USER_FAILURE, LOCATE_USER_START, LOCATE_USER_SUCCESS, LocationActionTypes, SELECT_LOCATION, SELECT_USER_LOCATION } from \"./types\";\n\nconst initialState: ILocationSearchState = {\n    selectedLocation: undefined,\n    geocodeResults: [],\n    geocodeIsLoading: false,\n    geocodeErrorMessage: '',\n    userLocation: undefined,\n    userLocationIsLoading: false,\n    userLocationErrorMessage: '',\n}\n\nexport function locationSearchReducer(state = initialState, action: LocationActionTypes): ILocationSearchState {\n    switch (action.type) {\n        case SELECT_LOCATION:\n            return {\n                ...state,\n                selectedLocation: action.location,\n            };\n        case SELECT_USER_LOCATION:\n            console.log(\"ldakfjaldkfjalkdsfjaldskfj\");\n            console.log(state);\n            return {\n                ...state,\n                selectedLocation: state.userLocation,\n            }\n        case GEOCODE_START:\n            return {\n                ...state,\n                geocodeIsLoading: true\n            };\n        case GEOCODE_SUCCESS:\n            return {\n                ...state,\n                geocodeIsLoading: false,\n                geocodeResults: action.results,\n                geocodeErrorMessage: \"\",\n            }\n        case GEOCODE_FAILURE:\n            return {\n                ...state,\n                geocodeIsLoading: false,\n                geocodeResults: [],\n                geocodeErrorMessage: action.errorMessage\n            };\n        case LOCATE_USER_START:\n            return {\n                ...state,\n                userLocationIsLoading: true,\n            }\n        case LOCATE_USER_SUCCESS:\n            return {\n                ...state,\n                userLocationIsLoading: false,\n                userLocation: action.location,\n            }\n        case LOCATE_USER_FAILURE:\n            return {\n                ...state,\n                userLocationIsLoading: false,\n                userLocationErrorMessage: action.errorMessage,\n            }\n\n        default:\n            return state;\n    }\n}","import { IWeatherState as IForecastState, ForecastActionTypes, FORECAST_FETCH_START, FORECAST_FETCH_SUCCESS, FORECAST_FETCH_FAILURE } from \"./types\";\nimport { createEmptyForecast } from \"../../weather\";\n\nconst initialState: IForecastState = {\n    forecast: createEmptyForecast(undefined),\n    isLoading: true,\n    errorMessage: undefined,\n}\n\nexport function forecastReducer(state = initialState, action: ForecastActionTypes): IForecastState {\n    switch (action.type) {\n        case FORECAST_FETCH_START:\n            console.log(\"Fetch start!!\")\n\n            return {\n                ...state,\n                isLoading: true,\n            };\n\n        case FORECAST_FETCH_SUCCESS:\n            console.log(\"Fetch success!!\");\n\n            return {\n                ...state,\n                forecast: action.forecast,\n                isLoading: false,\n                errorMessage: undefined,\n            };\n\n        case FORECAST_FETCH_FAILURE:\n            console.log(\"Fetch fail\")\n\n            return {\n                ...state,\n                isLoading: false,\n                errorMessage: action.errorMessage,\n            }\n\n        default:\n            return state;\n    }\n}\n","import { createStore, compose, combineReducers, applyMiddleware } from \"redux\";\nimport { locationSearchReducer } from \"./locationSearch/reducers\";\nimport thunk from 'redux-thunk';\nimport { forecastReducer } from \"./forecasts/reducers\";\n\nconst rootReducer = combineReducers({\n    locationSearch: locationSearchReducer,\n    forecasts: forecastReducer\n});\n\ndeclare global {\n    interface Window {\n        __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n    }\n}\n\nconst initialState = {}\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nexport default createStore(\n    rootReducer,\n    initialState,\n    compose(\n        applyMiddleware(thunk),\n        composeEnhancers()\n    )\n);\n\nexport type AppState = ReturnType<typeof rootReducer>\n","import ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { unregister } from './serviceWorker';\nimport store from \"./store\";\nimport { Provider } from 'react-redux';\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nunregister();\n"],"sourceRoot":""}