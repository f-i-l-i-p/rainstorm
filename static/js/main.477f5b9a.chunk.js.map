{"version":3,"sources":["icons/weather symbols/day_clear_sky.svg","icons/weather symbols sync /^/.//day_.*/.svg$","icons/weather symbols/day_cloudy_sky.svg","icons/weather symbols/day_half_clear_sky.svg","icons/weather symbols/day_light_rain.svg","icons/weather symbols/day_moderate_rain.svg","icons/weather symbols/day_moderate_rain_showers.svg","icons/weather symbols/day_moderate_sleet.svg","icons/weather symbols/day_nearly_clear_sky.svg","icons/weather symbols/day_overcast.svg","icons/weather symbols/day_thunder.svg","icons/weather symbols/day_thunderstorm.svg","icons/weather symbols/day_unknown.svg","weather/types.ts","store/forecasts/types.ts","icons/provider logos/SMHI.jpg","weather/weatherProviders/abstractProvider.ts","weather/weatherProviders/MET.ts","weather/index.ts","weather/weatherProviders/SMHI.ts","store/forecasts/actions.ts","components/atoms/Paper/index.tsx","components/weather/WeatherCell/index.tsx","components/weather/TimeCell/index.tsx","components/weather/WeatherTable/index.tsx","helpers/date.ts","components/weather/WeatherTableList/index.tsx","store/locationSearch/types.ts","store/locationSearch/actions.ts","components/atoms/SearchBox/index.tsx","components/pages/WeatherPage.tsx","App.tsx","serviceWorker.ts","store/locationSearch/reducers.ts","store/forecasts/reducers.ts","store/index.ts","index.tsx"],"names":["map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","module","exports","WeatherIcon","FORECAST_FETCH_START","FORECAST_FETCH_SUCCESS","FORECAST_FETCH_FAILURE","SET_DISPLAY_TIMES","AbstractProvider","name","logo","this","location","onSuccess","onFailure","requestData","lat","toString","long","response","formatResponse","result","console","error","MET","icons","light_rain","moderate_rain","clear_sky","half_clear_sky","cloudy_sky","fetch","ok","status","forecast","weatherPoints","json","timeSeries","properties","timeseries","currentDateTime","Date","getTime","i","length","timeobj","date","time","symbol_str","data","next_1_hours","summary","symbol_code","next_6_hours","next_12_hours","unknown","warn","weather","temperature","instant","details","air_temperature","wind","wind_speed","gust","NaN","symbol","push","weatherProviders","nearly_clear_sky","overcast","substr","forEach","parameters","parameter","value","getWeatherProviders","searchStart","provider","type","searchSuccess","searchFailure","errorMessage","Paper","props","className","style","children","Text","Typography","log","require","WeatherCell","undefined","Fragment","strong","Math","round","src","default","TimeCell","getHours","slice","WeatherTable","width","height","tableData","providers","ignored","index","margin","overflowX","columns","column","weatherMap","get","React","Component","listDates","start","interval","count","times","getDayOffset","today","setHours","setMinutes","setSeconds","setMilliseconds","diff","floor","WeatherTableList","stateForecasts","weatherStateForecasts","stateForecast","weatherProvider","loading","j","weatherPoint","weatherPointDate","dayOffset","Map","k","columnTime","set","splice","getDay","getTableData","getTableName","UPDATE_USER_LOCATION","SELECT_LOCATION","SEARCH_START","SEARCH_SUCCESS","SEARCH_FAILURE","nextSearchTime","now","lastSearch","results","tryPerformSearch","searchTerm","dispatch","performSearch","a","process","locations","toILocations","statusText","loc","country","Number","alt","message","Option","Select","SearchBox","state","searchText","handleTextChange","bind","navigator","geolocation","getCurrentPosition","pos","userLocation","coords","latitude","longitude","altitude","updateUserLocation","selectLocation","fetchForecasts","setState","searchLocations","locationResults","options","isLoading","CreateOption","display","flexDirection","justifyContent","showSearch","placeholder","size","defaultActiveFirstOption","showArrow","filterOption","onSearch","handleSearch","onChange","onSelect","handleSelect","notFoundContent","content","key","connect","selectedLocation","locationSearch","searchResults","trimmed","trim","setTimeout","minSearchDelay","search","fetchForecast","WeatherPage","displayTimes","forecasts","setDisplayTimes","App","Boolean","window","hostname","match","initialState","createInitialForecasts","listHoursFromNow","nothing","rootReducer","combineReducers","action","weatherStateForecast","newWeatherStateForecasts","JSON","parse","stringify","find","element","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","applyMiddleware","thunk","ReactDOM","render","store","document","getElementById","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"wGAAA,OAAe,cAA0B,2C,kICAzC,IAAIA,EAAM,CACT,sBAAuB,IACvB,uBAAwB,IACxB,2BAA4B,IAC5B,uBAAwB,IACxB,0BAA2B,IAC3B,kCAAmC,IACnC,2BAA4B,IAC5B,6BAA8B,IAC9B,qBAAsB,IACtB,oBAAqB,IACrB,yBAA0B,IAC1B,oBAAqB,KAItB,SAASC,EAAeC,GACvB,IAAIC,EAAKC,EAAsBF,GAC/B,OAAOG,EAAoBF,GAE5B,SAASC,EAAsBF,GAC9B,IAAIG,EAAoBC,EAAEN,EAAKE,GAAM,CACpC,IAAIK,EAAI,IAAIC,MAAM,uBAAyBN,EAAM,KAEjD,MADAK,EAAEE,KAAO,mBACHF,EAEP,OAAOP,EAAIE,GAEZD,EAAeS,KAAO,WACrB,OAAOC,OAAOD,KAAKV,IAEpBC,EAAeW,QAAUR,EACzBS,EAAOC,QAAUb,EACjBA,EAAeE,GAAK,K,iCCjCpB,OAAe,cAA0B,4C,iCCAzC,OAAe,cAA0B,gD,iCCAzC,OAAe,cAA0B,4C,iCCAzC,OAAe,cAA0B,+C,iCCAzC,OAAe,cAA0B,uD,iCCAzC,OAAe,cAA0B,gD,iCCAzC,OAAe,cAA0B,kD,iCCAzC,OAAe,cAA0B,0C,iCCAzC,OAAe,cAA0B,yC,iCCAzC,OAAe,cAA0B,8C,iCCAzC,OAAe,cAA0B,yC,wFCwB7BY,E,kHCVCC,EAAuB,uBAOvBC,EAAyB,yBAQzBC,EAAyB,yBAQzBC,EAAoB,oBCrClB,MAA0B,kC,SFwB7BJ,K,kBAAAA,E,sBAAAA,E,oCAAAA,E,gCAAAA,E,wBAAAA,E,oBAAAA,E,wBAAAA,E,8BAAAA,E,yBAAAA,M,SGrBkBK,E,WAI1B,WAAYC,EAAcC,GAAe,yBAHzCD,UAGwC,OAFxCC,UAEwC,EACpCC,KAAKF,KAAOA,EACZE,KAAKD,KAAOA,E,wFAGhB,WAA2BE,EAAqBC,EAAuCC,GAAvF,kGAK6BH,KAAKI,YAAYH,EAASI,IAAIC,WAAYL,EAASM,KAAKD,YALrF,cAKYE,EALZ,gBAQuBR,KAAKS,eAAeD,GAR3C,OAQQE,EARR,8DAWQC,QAAQC,MAAR,MACAT,EAAU,EAAD,IAZjB,2BAgBID,EAAUQ,GAhBd,yD,kECPiBG,E,kDACjB,aAAe,IAAD,8BACV,cAAM,KAAMd,IAGRe,MAAa,CACjB,UAAatB,EAAYuB,WACzB,KAAQvB,EAAYwB,cACpB,eAAkBxB,EAAYyB,UAC9B,iBAAoBzB,EAAY0B,eAChC,mBAAsB1B,EAAY0B,eAClC,OAAU1B,EAAY2B,YAVZ,E,sFAad,WAA4Bd,EAAaE,GAAzC,uFACyBa,MAAM,kEACrBf,EAAM,QAAUE,GAF1B,WACUG,EADV,QAIgBW,GAJhB,sBAKc,IAAIpC,MAAM,mCAAqCyB,EAAOY,QALpE,gCAQWZ,GARX,2C,4HAWA,WAA+BF,GAA/B,8FACQe,EAAsB,CACtBC,cAAe,IAFvB,SAKuBhB,EAASiB,OALhC,OAKUA,EALV,OAOUC,EAAiBD,EAAKE,WAAWC,WAEjCC,GAAkB,IAAIC,MAAOC,UAG1BC,EAAI,EAZjB,YAYoBA,EAAIN,EAAWO,QAZnC,oBAacC,EAAeR,EAAWM,MAC1BG,EAAa,IAAIL,KAAKI,EAAQE,OAG3BL,UAAYF,GAjB7B,2DAqBYQ,OArBZ,GAsBYH,EAAQI,KAAKC,aAtBzB,iBAuBYF,EAAaH,EAAQI,KAAKC,aAAaC,QAAQC,YAvB3D,4BAyBiBP,EAAQI,KAAKI,aAzB9B,iBA0BYL,EAAaH,EAAQI,KAAKI,aAAaF,QAAQC,YA1B3D,4BA4BiBP,EAAQI,KAAKK,cA5B9B,iBA6BYN,EAAaH,EAAQI,KAAKK,cAAcH,QAAQC,YA7B5D,gEAmCuBzC,KAAKc,MAAMuB,IAAe7C,EAAYoD,WACtCpD,EAAYoD,SACvBjC,QAAQkC,KAAK,iBAAkBR,GAG7BS,EAAoB,CACtBC,YAAab,EAAQI,KAAKU,QAAQC,QAAQC,gBAC1CC,KAAMjB,EAAQI,KAAKU,QAAQC,QAAQG,WACnCC,KAAMC,IACNC,OAAQvD,KAAKc,MAAMuB,IAAe7C,EAAYoD,SAGlDrB,EAASC,cAAcgC,KAAK,CAAEpB,KAAMD,EAAMW,QAASA,IA/C3D,QAY2Cd,IAZ3C,gDAkDWT,GAlDX,iD,4DAzB6B1B,GCC3B4D,EAAuC,CAAC,I,kDCA1C,aAAe,IAAD,8BACV,cAAM,OAAQ1D,IAGVe,MAAQ,CACZ,EAAGtB,EAAYyB,UACf,EAAGzB,EAAYkE,iBACf,EAAGlE,EAAY0B,eACf,EAAG1B,EAAY0B,eACf,EAAG1B,EAAY2B,WACf,EAAG3B,EAAYmE,SACf,GAAInE,EAAYuB,WAChB,GAAIvB,EAAYwB,eAZN,E,sFAed,WAA4BX,EAAaE,GAAzC,8EACgB,EADhB,SAEyBa,MAAM,4FACrBb,EAAKqD,OAAO,EAFN,GAEgB,QAAUvD,EAAIuD,OAAO,EAFrC,GAE+C,cAH/D,WAEUlD,EAFV,QAKgBW,GALhB,sBAMc,IAAIpC,MAAM,qDANxB,gCASWyB,GATX,2C,4HAYA,WAA+BF,GAA/B,2FACQe,EAAsB,CACtBC,cAAe,IAFvB,SAKuBhB,EAASiB,OALhC,cAKUA,EALV,OAOUC,EAAiBD,EAAI,WAErBI,GAAkB,IAAIC,MAAOC,UAEnCL,EAAWmC,SAAQ,SAACzB,GAEhB,IAAMD,EAAO,IAAIL,KAAKM,EAAI,WAE1B,GAAID,EAAKJ,WAAaF,EAAiB,CAMnC,IAAMiC,EAAiB1B,EAAI,WAErBU,EAAoB,CACtBC,YAAaO,IACbH,KAAMG,IACND,KAAMC,IACNC,OAAQ/D,EAAYoD,SAIxBkB,EAAWD,SAAQ,SAAAE,GACf,IAAMC,EAAQD,EAAS,OAAW,GAClC,OAAQA,EAAS,MACb,IAAK,IACDjB,EAAQC,YAAciB,EACtB,MACJ,IAAK,KACDlB,EAAQK,KAAOa,EACf,MACJ,IAAK,OACDlB,EAAQO,KAAOW,EACf,MACJ,IAAK,SAED,IADW,EAAKlD,MAAMkD,GACX,CACPrD,QAAQkC,KAAK,uBAAwBmB,GACrClB,EAAQS,OAAS/D,EAAYoD,QAC7B,MAEJE,EAAQS,OAAS,EAAKzC,MAAMkD,OAKxCzC,EAASC,cAAcgC,KAAK,CAAEpB,KAAMD,EAAMW,QAASA,QAvD/D,kBA2DWvB,GA3DX,2C,4DA5B8B1B,IDCwB,IAAIgB,GAGvD,SAASoD,IACZ,OAAOR,EEJX,SAASS,EAAYC,GACjB,MAAO,CACHC,KAAM3E,EACN0E,SAAUA,GAIlB,SAASE,EAAcF,EAA4B5C,GAC/C,MAAO,CACH6C,KAAM1E,EACN6B,SAAUA,EACV4C,SAAUA,GAIlB,SAASG,EAAcH,EAA4BI,GAC/C,MAAO,CACHH,KAAMzE,EACN4E,aAAcA,EACdJ,SAAUA,G,yBCTHK,EAND,SAACC,GAAD,OACV,qBAAKC,UAAU,QAAQC,MAAOF,EAAME,MAApC,SACKF,EAAMG,Y,SCNPC,G,OAASC,IAATD,MAMRlE,QAAQoE,IAAIC,EAAQ,MAEpB,IAmBeC,EAnBK,SAACR,GAAD,OAChB,qBAAKC,UAAU,eAAf,cACsBQ,GAAjBT,EAAM3B,SACH,eAAC,IAAMqC,SAAP,WACI,eAACN,EAAD,CAAMO,QAAM,EAAZ,UAAcC,KAAKC,MAAMb,EAAM3B,QAAQC,aAAvC,YACC0B,EAAM3B,QAAQS,QACX,qBAAKmB,UAAU,iBAAiBa,IAAKP,OAAQ,SAAwCP,EAAM3B,QAAQS,OAAS,QAAQiC,UAExH,gCACI,cAACX,EAAD,CAAMO,QAAM,EAAZ,SAAcC,KAAKC,MAAMb,EAAM3B,QAAQK,QACvC,eAAC0B,EAAD,CAAMT,KAAK,YAAX,eAA0BiB,KAAKC,MAAMb,EAAM3B,QAAQO,MAAnD,QACA,cAACwB,EAAD,CAAMO,QAAM,EAAZ,0B,SCpBZP,G,OAASC,IAATD,MAYOY,EANE,SAAChB,GAAD,OACb,qBAAKC,UAAU,YAAf,SACI,cAAC,EAAD,CAAMU,QAAM,EAAZ,UAAe,IAAMX,EAAMrC,KAAKsD,YAAYC,OAAO,QCoE5CC,G,mKAlEX,WAAiB,IAAD,OACZ,OACI,gCACK5F,KAAKyE,MAAM3E,KACZ,sBAAK4E,UAAU,UAAf,UAGI,qBAAKA,UAAU,eAAf,SACI,qBAAKA,UAAU,WAAWC,MAAO,CAAEkB,MAAO,QAA1C,SACI,cAAC,EAAD,CAAOlB,MAAO,CAAEkB,MAAO,OAAQC,OAAQ,cAK/C,sBAAKpB,UAAU,cAAf,UACI,qBAAKA,UAAU,aACd1E,KAAKyE,MAAMsB,UAAUC,UAAUvH,KAAI,SAACwH,EAASC,GAAV,OAChC,qBAAiBxB,UAAU,cAA3B,SACI,cAAC,EAAD,CAAOC,MAAO,CAAEkB,MAAO,OAAQC,OAAQ,WADjCI,SAOlB,sBAAKxB,UAAU,cAAf,UACI,qBAAKA,UAAU,aACd1E,KAAKyE,MAAMsB,UAAUC,UAAUvH,KAAI,SAAC0F,EAAU+B,GAAX,OAChC,qBAAiBxB,UAAU,cAA3B,SACI,cAAC,IAAD,CAAYA,UAAU,wBAAtB,SACKP,EAASrE,QAFRoG,SASlB,sBAAKxB,UAAU,iBAAf,UACI,qBAAKA,UAAU,aACd1E,KAAKyE,MAAMsB,UAAUC,UAAUvH,KAAI,SAACwH,EAASC,GAAV,OAChC,qBAAiBxB,UAAU,cAA3B,SACI,cAAC,IAAD,CAASN,KAAK,WAAWO,MAAO,CAAEmB,OAAQ,mBAAoBK,OAAQ,MADhED,SAOlB,sBAAKxB,UAAU,eAAeC,MAAO,CAAEyB,UAAW,QAAlD,UACI,qBAAK1B,UAAU,WAAf,SACK1E,KAAKyE,MAAMsB,UAAUM,QAAQ5H,KAAI,SAAC6H,EAAQJ,GAAT,OAC9B,cAAC,EAAD,CAAsB9D,KAAMkE,EAAOnE,MAApB+D,QAGtBlG,KAAKyE,MAAMsB,UAAUC,UAAUvH,KAAI,SAAC0F,EAAU+B,GAAX,OAChC,qBAAiBxB,UAAU,cAA3B,SACK,EAAKD,MAAMsB,UAAUM,QAAQ5H,KAAI,SAAC6H,EAAQJ,GAAT,OAC9B,cAAC,EAAD,CAAyBpD,QAASwD,EAAOC,WAAWC,IAAIrC,IAAtC+B,OAFhBA,mB,GAtDXO,IAAMC,Y,OCwB1B,SAASC,EAAUC,EAAaC,EAAkBC,GAGrD,IAFA,IAAIC,EAAgB,GAEX/E,EAAI,EAAGA,EAAI8E,EAAO9E,IACvB+E,EAAMvD,KAAK,IAAI1B,KAAK8E,EAAM7E,UAAaC,EAAI6E,IAG/C,OAAOE,EAMJ,SAASC,EAAa7E,GACzB,IAAI8E,EAAQ,IAAInF,KAChBmF,EAAMC,SAAS,GACfD,EAAME,WAAW,GACjBF,EAAMG,WAAW,GACjBH,EAAMI,gBAAgB,GAEtB,IAAIC,EAAOnF,EAAKJ,UAAYkF,EAAMlF,UAElC,OAAOsD,KAAKkC,MAAMD,EAAO,O,IC9CRE,E,kKAMjB,WAOI,IANA,IAAM9G,EAAuB,GAEvB+G,EAAiBzH,KAAKyE,MAAMiD,sBAC5B1B,EAAYyB,EAAehJ,KAAI,SAAAkJ,GAAmB,OAAOA,EAAcC,mBAGpE5F,EAAI,EAAGA,EAAIyF,EAAexF,OAAQD,IAAK,CAC5C,IAAM2F,EAAgBF,EAAezF,GAErC,IAAI2F,EAAcE,QAKlB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAcpG,SAASC,cAAcS,OAAQ6F,IAAK,CAClE,IAAMC,EAAeJ,EAAcpG,SAASC,cAAcsG,GAGtDE,OAAsB,EAMpBC,EAAYjB,EAJdgB,EAD6B,kBAAtBD,EAAa3F,KACD,IAAIN,KAAKiG,EAAa3F,MAEtB2F,EAAa3F,MAIpC,GAAI6F,EAAY,EACZtH,QAAQkC,KAAK,wBADjB,CAMIoF,GAAavH,EAAOuB,QACpBvB,EAAO8C,KAAK,CACR6C,QAAS,GACTL,UAAWA,IAInB,IAAMD,EAAYrF,EAAOuH,GACnB7F,EAAO4F,EAAiBjG,UAGG,IAA7BgE,EAAUM,QAAQpE,QAClB8D,EAAUM,QAAQ7C,KAAK,CACnBrB,KAAM6F,EACNzB,WAAY,IAAI2B,MAKxB,IAAK,IAAIC,EAAIpC,EAAUM,QAAQpE,OAAS,EAAGkG,GAAK,EAAGA,IAAK,CACpD,IAAM7B,EAASP,EAAUM,QAAQ8B,GAC3BC,EAAa9B,EAAOnE,KAAKJ,UAG/B,GAAIqG,IAAehG,EAAM,CAErBkE,EAAOC,WAAW8B,IAAIV,EAAcC,gBAAiBG,EAAajF,SAClE,MAGKsF,EAAahG,IAElB2D,EAAUM,QAAQiC,OAAOH,EAAI,EAAG,EAAG,CAC/BhG,KAAM6F,EACNzB,WAAY,IAAI2B,MAIpBC,GAAK,MAMrB,OAAOzH,I,0BAGX,SAAqBwF,EAAe/D,GAChC,IAAIzB,EAAS,GAEb,IAAKyB,EAAM,OAAOzB,EAElB,OAAQwF,GACJ,KAAK,EACDxF,GAAU,SACV,MACJ,KAAK,EACDA,GAAU,YAGlB,OAAQyB,EAAKoG,UACT,KAAK,EACD7H,GAAU,YACV,MACJ,KAAK,EACDA,GAAU,SACV,MACJ,KAAK,EACDA,GAAU,SACV,MACJ,KAAK,EACDA,GAAU,UACV,MACJ,KAAK,EACDA,GAAU,SACV,MACJ,KAAK,EACDA,GAAU,YACV,MACJ,KAAK,EACDA,GAAU,YAIlB,OAAOA,I,oBAGX,WAAiB,IAAD,OACRqF,EAAY/F,KAAKwI,eAErB,OACI,qBAAK9D,UAAU,OAAf,SACKqB,EAAUtH,KAAI,SAAC6D,EAAM4D,GAAP,OACX,cAAC,EAAD,CAA0BH,UAAWzD,EAAMxC,KAAM,EAAK2I,aAAavC,EAAO5D,EAAK+D,QAAQpE,OAASK,EAAK+D,QAAQ,GAAGlE,UAAO+C,IAApGgB,Y,GApIOO,IAAMC,W,2CCJvCgC,EAAuB,uBAOvBC,EAAkB,kBAOlBC,EAAe,eAMfC,EAAiB,iBAOjBC,EAAiB,iBC/B1BC,EAAyBjH,KAAKkH,MAC9BC,EAAqB,GAuBzB,SAAS5E,EAAc6E,GACnB,MAAO,CACH9E,KAAMyE,EACNK,QAASA,GAIjB,SAAS5E,EAAcC,GACnB,MAAO,CACHH,KAAM0E,EACNvE,aAAcA,GAqBtB,SAAS4E,GAAiBC,EAAoBC,GACtCvH,KAAKkH,MAAQD,G,uCAIjBO,CAAcF,EAAYC,G,8CAG9B,WAA6BD,EAAoBC,GAAjD,mBAAAE,EAAA,4DACgBC,sCACI,iDAFpB,SAIyBpI,MAAM,GAAD,OAFV,iDAEU,gBAHdoI,sCAGc,cAA4BJ,EAA5B,wBAJ9B,cAIU1I,EAJV,gBAMuBA,EAAOe,OAN9B,OAMUA,EANV,OAQQf,EAAOW,IACDoI,EAAYC,GAAajI,GAC/B4H,EAAShF,EAAcoF,KAGA,qBAAjBhI,EAAI,MAEV4H,EAAShF,EADsB,MAI/B1D,QAAQC,MAAM,mCAAqCF,EAAOiJ,YAC1DN,EAAS/E,EAAc5D,EAAOY,OAAOhB,cAnB7C,4C,sBAwBA,SAASoJ,GAAajI,GAClB,IAAMgI,EAAyB,GAE/B,IAAK,IAAD,gBACkBhI,GADlB,IACA,2BAAwB,CAAC,IAAdmI,EAAa,QACpBH,EAAUjG,KAAK,CACXqG,QAASD,EAAG,gBACZ9J,KAAM8J,EAAG,cACTvJ,IAAKyJ,OAAOF,EAAG,KACfrJ,KAAMuJ,OAAOF,EAAG,KAChBG,IAAK,KAPb,8BAYA,OADApJ,QAAQoE,IAAI0E,GACLA,EAEX,MAAO7I,GAEH,OADAD,QAAQC,MAAMA,EAAMoJ,SACb,ICxGf,IAAQC,GAAWC,IAAXD,OACApF,GAASC,IAATD,KAkBFsF,G,kDACF,WAAY1F,GAAoC,IAAD,8BAC3C,cAAMA,IAED2F,MAAQ,CACTC,WAAY,IAGhB,EAAKC,iBAAmB,EAAKA,iBAAiBC,KAAtB,gBAPmB,E,qDAU/C,WAAqB,IAAD,OAGhBC,UAAUC,YAAYC,oBAAmB,SAAAC,GACrC,IAAMC,EAA0B,CAC5Bf,QAAS,GACT/J,KAAM,gBACNO,IAAKsK,EAAIE,OAAOC,SAChBvK,KAAMoK,EAAIE,OAAOE,UACjBhB,IAAKY,EAAIE,OAAOG,SAAWL,EAAIE,OAAOG,SAAW,GAGrD,EAAKvG,MAAMwG,mBAAmBL,GAE9B,EAAKnG,MAAMyG,eAAeN,GAE1B,EAAKnG,MAAM0G,eAAeP,MAC3B,SAAAhK,S,8BAMP,SAAyBoD,GACrBhE,KAAKoL,SAAL,2BACOpL,KAAKoK,OADZ,IAEIC,WAAYrG,O,0BAIpB,SAAqBA,GACZA,GACLhE,KAAKyE,MAAM4G,gBAAgBrH,K,0BAG/B,SAAqBA,GAEjB,IADA,IAAMkF,EAAUlJ,KAAKyE,MAAM6G,gBAClBtJ,EAAI,EAAGA,EAAIkH,EAAQjH,OAAQD,IAChC,GAAIkH,EAAQlH,GAAGlC,OAASkE,EAAO,CAC3BhE,KAAKyE,MAAMyG,eAAehC,EAAQlH,IAClChC,KAAKyE,MAAM0G,eAAejC,EAAQlH,IAClC,S,oBAKZ,WAAiB,IAAD,OACRuJ,EAAyB,GAG7B,GAAIvL,KAAKyE,MAAM+G,UACXD,EAAQ/H,KAAKiI,GAAa,cAAC,IAAD,IAAU,OAAQ,SAG5C,GAAIzL,KAAKyE,MAAMF,aACXgH,EAAQ/H,KAAKiI,GACT,eAAC,GAAD,CAAMrH,KAAK,SAAX,qCAA6CpE,KAAKyE,MAAMF,gBACxD,QAAS,SAMb,GAA0C,IAAtCvE,KAAKyE,MAAM6G,gBAAgBrJ,OAC3BsJ,EAAQ/H,KAAKiI,GAAa,cAAC,GAAD,kCAAkC,eAAgB,SAK5E,IAFA,IAAMhC,EAAYzJ,KAAKyE,MAAM6G,gBAEpBtJ,EAAI,EAAGA,EAAIyH,EAAUxH,OAAQD,IAAK,CACvC,IAAM/B,EAAWwJ,EAAUzH,GAE3BuJ,EAAQ/H,KAAKiI,GACT,sBAAK9G,MAAO,CAAE+G,QAAS,OAAQC,cAAe,SAAUC,eAAgB,iBAAxE,UACI,eAAC,GAAD,CAAMxG,QAAM,EAAZ,UAAcnF,EAASH,KAAvB,QACC,cAAC,GAAD,CAAMsE,KAAK,YAAX,SAAwBnE,EAAS4J,aAEtC5J,EAASH,KACTkC,IAOpB,OACI,cAAC,IAAD,CACI6J,YAAU,EACVlH,MAAO3E,KAAKyE,MAAME,MAClBX,MAAOhE,KAAKoK,MAAMC,WAAarK,KAAKoK,MAAMC,gBAAanF,EACvD4G,YAAY,SACZC,KAAK,QACLC,0BAA0B,EAC1BC,WAAW,EACXC,cAAc,EACdC,SAAU,SAAAnI,GAAK,OAAI,EAAKoI,aAAapI,IACrCqI,SAAU,SAAArI,GAAK,OAAI,EAAKsG,iBAAiBtG,IACzCsI,SAAU,SAAAtI,GAAK,OAAI,EAAKuI,aAAavI,IACrCwI,gBAAiB,KAZrB,SAcKjB,Q,GA/GO9E,IAAMC,WAqH9B,SAAS+E,GAAagB,EAAsBzI,EAAe0I,GACvD,OACI,cAACzC,GAAD,CAAQjG,MAAOA,EAAf,SACKyI,GADsBC,GAwBpBC,oBAlBf,SAAyBvC,GACrB,MAAO,CACHwC,iBAAkBxC,EAAMyC,eAAeD,iBACvCtB,gBAAiBlB,EAAMyC,eAAeC,cACtCtB,UAAWpB,EAAMyC,eAAerB,UAChCjH,aAAc6F,EAAMyC,eAAetI,iBAI3C,SAA4B8E,GACxB,MAAO,CACH6B,eAAgB,SAACjL,GAAD,OAAyBoJ,EDlJ1C,SAAwBpJ,GAC3B,MAAO,CACHmE,KAAMuE,EACNiE,iBAAkB3M,GC+IgCiL,CAAejL,KACjEoL,gBAAiB,SAACjC,GAAD,OAAwBC,EDxH3B,SAACD,GAAD,8CAAwB,WAAOC,GAAP,eAAAE,EAAA,0DACpCwD,EAAU3D,EAAW4D,UACX/D,EAF0B,iDAM1CA,EAAa8D,EAEb1D,EA3BO,CACHjF,KAAMwE,IA4BVG,EAAiBjH,KAAKkH,MAjDK,IAkD3BiE,YAAW,kBAAM9D,GAAiBC,EAAYC,KAAW6D,MAXf,2CAAxB,sDCwHoCC,CAAO/D,KACzD+B,eAAgB,SAAClL,GAAD,OAAyBoJ,ETxInB,SAACpJ,GAAD,8CAAyB,WAAOoJ,GAAP,iBAAAE,EAAA,sDAC7CrJ,EAAY,SAACiE,EAA4BzD,GAA7B,OAAmD2I,EAAShF,EAAcF,EAAUzD,KAChGP,EAAY,SAACgE,EAA4BvD,GAA7B,OAA8CyI,EAAS/E,EAAcH,EAAUvD,EAAMoJ,WAErF/F,IAERJ,SAAQ,SAAAM,GACdkF,EAASnF,EAAYC,IACrBA,EAASiJ,cAAcnN,GAAU,SAACS,GAAD,OAAuBR,EAAUiE,EAAUzD,MAAS,SAACE,GAAD,OAAkBT,EAAUgE,EAAUvD,SAR5E,2CAAzB,sDSwI4BuK,CAAelL,KACjEgL,mBAAoB,SAAChL,GAAD,OAA0BoJ,ED5J/C,SAA4BpJ,GAC/B,MAAO,CACHmE,KAAMsE,EACNzI,SAAUA,GCyJ6CgL,CAAmBhL,QAInE0M,CAA6CxC,ICrJtDkD,G,4JACF,WAEI,OADA1M,QAAQoE,IAAI,YAER,gCACI,cAAC,GAAD,CAAWJ,MAAO,CAACkB,MAAO,UAC1B,cAAC,EAAD,CAAkB6B,sBAAuB1H,KAAKyE,MAAMiD,+B,GAN1CjB,IAAMC,WA0BjBiG,oBAdf,SAAyBvC,GACrB,MAAO,CACHnK,SAAUmK,EAAMyC,eAAeD,iBAC/BU,aAAclD,EAAMmD,UAAUD,aAC9B5F,sBAAuB0C,EAAMmD,UAAU7F,0BAI/C,SAA4B2B,GACxB,MAAO,CACHmE,gBAAiB,SAACpL,GAAD,OAAkBiH,EVAhC,CACHjF,KAAMxE,EACN0N,aUF4DlL,QAIrDuK,CAA6CU,IC/B7CI,OAVf,WACE,OACE,qBAAK7O,GAAG,MAAR,SACE,qBAAK8F,UAAU,OAAf,SACE,cAAC,GAAD,SCEYgJ,QACW,cAA7BC,OAAO1N,SAAS2N,UAEe,UAA7BD,OAAO1N,SAAS2N,UAEhBD,OAAO1N,SAAS2N,SAASC,MACvB,2D,aChBAC,GAAqC,CACvClB,sBAAkB1H,EAClB4H,cAAe,GACftB,WAAW,EACXjH,aAAc,GACdqG,kBAAc1F,G,cCHZ4I,GAA+B,CACjCpG,sBAsDJ,WACI,IAAI6F,EAAqC,GAgBzC,OAfkBtJ,IAERJ,SAAQ,SAAAM,GACd,IAAI5C,EAAkC,CAClCqG,gBAAiBzD,EACjB0D,SAAS,EACTtG,SAAU,CACNC,cAAe,KAGvB+L,EAAU/J,KAAKjC,MAGnBZ,QAAQoE,IAAI,qBAAsBwI,GAE3BA,EAvEgBQ,GACvBT,aTFG,SAA0BxG,GAC7B,IAAIF,EAAQ,IAAI9E,KAKhB,OAJA8E,EAAMM,SAASN,EAAMlB,WAAa,GAClCkB,EAAMO,WAAW,GACjBP,EAAMQ,WAAW,GACjBR,EAAMS,gBAAgB,GACfV,EAAUC,EAAO,KAASE,GSJnBkH,CAAiB,IAC/BC,QAAS,GCFb,IAAMC,GAAcC,aAAgB,CAChCtB,eFIG,WAA+G,IAAhFzC,EAA+E,uDAAvE0D,GAAcM,EAAyD,uCACjH,OAAQA,EAAOhK,MACX,KAAKsE,EACD,OAAO,2BACA0B,GADP,IAEIQ,aAAcwD,EAAOnO,WAE7B,KAAK0I,EACD,OAAO,2BACAyB,GADP,IAEIwC,iBAAkBwB,EAAOxB,mBAEjC,KAAKhE,EACD,OAAO,2BACAwB,GADP,IAEIoB,WAAW,IAEnB,KAAK3C,EACD,OAAO,2BACAuB,GADP,IAEIoB,WAAW,EACXsB,cAAesB,EAAOlF,QACtB3E,aAAc,KAEtB,KAAKuE,EACD,OAAO,2BACAsB,GADP,IAEIoB,WAAW,EACXsB,cAAe,GACfvI,aAAc6J,EAAO7J,eAE7B,QACI,OAAO6F,IEnCfmD,UDGG,WAA6F,IAApEnD,EAAmE,uDAA3D0D,GAAcM,EAA6C,uCAC/F,OAAQA,EAAOhK,MACX,KAAK3E,EAUD,OATAkB,QAAQoE,IAAI,sBAKiBG,KADzBmJ,GAFAC,EAAoDC,KAAKC,MAAMD,KAAKE,UAAUrE,EAAM1C,yBAEpCgH,MAAK,SAAAC,GAAO,OAAIA,EAAQ/G,gBAAgB9H,OAASsO,EAAOjK,SAASrE,WAEjHuO,EAAqBxG,SAAU,GAG5B,2BACAuC,GADP,IAEI1C,sBAAuB4G,IAG/B,KAAK5O,EAGD,IAAI4O,EAEAD,EAMJ,OAVA1N,QAAQoE,IAAI,wBAKiBG,KADzBmJ,GAFAC,EAAoDC,KAAKC,MAAMD,KAAKE,UAAUrE,EAAM1C,yBAEpCgH,MAAK,SAAAC,GAAO,OAAIA,EAAQ/G,gBAAgB9H,OAASsO,EAAOjK,SAASrE,WAEjHuO,EAAqBxG,SAAU,EAC/BwG,EAAqB9M,SAAW6M,EAAO7M,UAGpC,2BACA6I,GADP,IAEI1C,sBAAuB4G,IAG/B,KAAK3O,EAKD,OAJAgB,QAAQoE,IAAI,cAIL,eAAKqF,GAEhB,KAAKxK,EAIL,QACI,OAAOwK,MCrCbwE,GAAmBjB,OAAOkB,sCAAwCC,KAEzDC,gBACXb,GALiB,GAOjBY,aACIE,aAAgBC,MAChBL,OCjBRM,IAASC,OACL,cAAC,IAAD,CAAUC,MAAOA,GAAjB,SACI,cAAC,GAAD,MAEJC,SAASC,eAAe,SJ+HtB,kBAAmB9E,WACrBA,UAAU+E,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAhP,GACLD,QAAQC,MAAMA,EAAMoJ,c","file":"static/js/main.477f5b9a.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/day_clear_sky.3cec5a70.svg\";","var map = {\n\t\"./day_clear_sky.svg\": 104,\n\t\"./day_cloudy_sky.svg\": 209,\n\t\"./day_half_clear_sky.svg\": 210,\n\t\"./day_light_rain.svg\": 211,\n\t\"./day_moderate_rain.svg\": 212,\n\t\"./day_moderate_rain_showers.svg\": 213,\n\t\"./day_moderate_sleet.svg\": 214,\n\t\"./day_nearly_clear_sky.svg\": 215,\n\t\"./day_overcast.svg\": 216,\n\t\"./day_thunder.svg\": 217,\n\t\"./day_thunderstorm.svg\": 218,\n\t\"./day_unknown.svg\": 219\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 208;","export default __webpack_public_path__ + \"static/media/day_cloudy_sky.28c5a064.svg\";","export default __webpack_public_path__ + \"static/media/day_half_clear_sky.f2367887.svg\";","export default __webpack_public_path__ + \"static/media/day_light_rain.8de418d1.svg\";","export default __webpack_public_path__ + \"static/media/day_moderate_rain.1ac9a777.svg\";","export default __webpack_public_path__ + \"static/media/day_moderate_rain_showers.5bdbfbe3.svg\";","export default __webpack_public_path__ + \"static/media/day_moderate_sleet.b195ed64.svg\";","export default __webpack_public_path__ + \"static/media/day_nearly_clear_sky.9a7090ce.svg\";","export default __webpack_public_path__ + \"static/media/day_overcast.062fc05d.svg\";","export default __webpack_public_path__ + \"static/media/day_thunder.08acff3b.svg\";","export default __webpack_public_path__ + \"static/media/day_thunderstorm.fb8d6c57.svg\";","export default __webpack_public_path__ + \"static/media/day_unknown.d6ceac86.svg\";","import { ILocation } from \"../store/types\";\n\nexport interface IForecast {\n    weatherPoints: IWeatherTime[],\n}\n\nexport interface IWeatherTime {\n    time: Date,\n    weather: IWeather,\n}\n\nexport interface IWeather {\n    temperature: number,\n    wind: number,\n    gust: number,\n    symbol: WeatherIcon,\n}\n\nexport interface IWeatherProvider {\n    name: string;\n    logo: string;\n    fetchForecast(location: ILocation, onSuccess: (result: IForecast) => any, onFailure: (error: Error) => any): void;\n}\n\nexport enum WeatherIcon {\n    unknown = \"unknown\",\n    // Cloudiness\n    clear_sky = \"clear_sky\",\n    nearly_clear_sky = \"nearly_clear_sky\",\n    half_clear_sky = \"half_clear_sky\",\n    cloudy_sky = \"cloudy_sky\",\n    overcast = \"overcast\",\n    // Rain\n    light_rain = \"light_rain\",\n    moderate_rain = \"moderate_rain\",\n    heavy_rain = \"heavy_rain\",\n}","import { IForecast, IWeatherProvider } from \"../../weather/types\";\n\nexport interface IWeatherStateForecast {\n    weatherProvider: IWeatherProvider;\n    loading: boolean;\n    forecast: IForecast;\n}\n\nexport interface IWeatherState {\n    weatherStateForecasts: IWeatherStateForecast[],\n    displayTimes: Date[],\n    nothing: number,\n}\n\nexport const FORECAST_FETCH_START = 'FORECAST_FETCH_START';\n\ninterface IFetchStartAction {\n    type: typeof FORECAST_FETCH_START,\n    provider: IWeatherProvider\n}\n\nexport const FORECAST_FETCH_SUCCESS = 'FORECAST_FETCH_SUCCESS';\n\ninterface IFetchSuccessAction {\n    type: typeof FORECAST_FETCH_SUCCESS,\n    forecast: IForecast,\n    provider: IWeatherProvider\n}\n\nexport const FORECAST_FETCH_FAILURE = 'FORECAST_FETCH_FAILURE';\n\ninterface IFetchFailureAction {\n    type: typeof FORECAST_FETCH_FAILURE,\n    errorMessage: string,\n    provider: IWeatherProvider\n}\n\nexport const SET_DISPLAY_TIMES = 'SET_DISPLAY_TIMES';\n\ninterface ISetDisplayTimesAction {\n    type: typeof SET_DISPLAY_TIMES,\n    displayTimes: Date[]\n}\n\nexport type ForecastActionTypes = IFetchStartAction | IFetchSuccessAction | IFetchFailureAction | ISetDisplayTimesAction;","export default __webpack_public_path__ + \"static/media/SMHI.147242e8.jpg\";","import { ILocation } from \"../../store/types\";\nimport { IForecast, IWeatherProvider } from \"../types\";\n\nexport default abstract class AbstractProvider implements IWeatherProvider {\n    name: string;\n    logo: string;\n\n    constructor(name: string, logo: string) {\n        this.name = name;\n        this.logo = logo;\n    }\n\n    public async fetchForecast(location: ILocation, onSuccess: (result: IForecast) => any, onFailure: (error: Error) => any) {\n        let result: IForecast;\n\n        try {\n            // Send a request\n            let response = await this.requestData(location.lat.toString(), location.long.toString());\n\n            // Format the response \n            result = await this.formatResponse(response);\n\n        } catch (e) {\n            console.error(e)\n            onFailure(e);\n            return;\n        }\n\n        onSuccess(result)\n    }\n\n    protected abstract requestData(lat: string, long: string): Promise<Response>;\n    protected abstract formatResponse(response: Response): Promise<IForecast>;\n}","import logo from '../../icons/provider logos/SMHI.jpg'\nimport { IForecast, IWeather, IWeatherTime, WeatherIcon } from \"../types\";\nimport AbstractProvider from \"./abstractProvider\";\n\n\nexport default class MET extends AbstractProvider {\n    constructor() {\n        super(\"Yr\", logo)\n    }\n\n    private icons: any = {\n        \"lightrain\": WeatherIcon.light_rain,\n        \"rain\": WeatherIcon.moderate_rain,\n        \"clearsky_night\": WeatherIcon.clear_sky,\n        \"partlycloudy_day\": WeatherIcon.half_clear_sky,\n        \"partlycloudy_night\": WeatherIcon.half_clear_sky,\n        \"cloudy\": WeatherIcon.cloudy_sky,\n    }\n\n    protected async requestData(lat: string, long: string): Promise<Response> {\n        const result = await fetch('https://api.met.no/weatherapi/locationforecast/2.0/compact?lat='\n            + lat + '&lon=' + long);\n\n        if (!result.ok) {\n            throw new Error(\"Weather response error! status: \" + result.status)\n        }\n\n        return result;\n    }\n\n    protected async formatResponse(response: Response): Promise<IForecast> {\n        let forecast: IForecast = {\n            weatherPoints: [],\n        }\n\n        const json = await response.json();\n\n        const timeSeries: [] = json.properties.timeseries;\n\n        const currentDateTime = new Date().getTime();\n\n        // Loop through all timeseries\n        for (let i = 0; i < timeSeries.length; i++) {\n            const timeobj: any = timeSeries[i];\n            const date: Date = new Date(timeobj.time);\n\n            // If this is old weather.\n            if (date.getTime() < currentDateTime) {\n                continue;\n            }\n\n            let symbol_str: string;\n            if (timeobj.data.next_1_hours) {\n                symbol_str = timeobj.data.next_1_hours.summary.symbol_code;\n            }\n            else if (timeobj.data.next_6_hours) {\n                symbol_str = timeobj.data.next_6_hours.summary.symbol_code;\n            }\n            else if (timeobj.data.next_12_hours) {\n                symbol_str = timeobj.data.next_12_hours.summary.symbol_code;\n            }\n            else {\n                continue;\n            }\n\n            const symbol = this.icons[symbol_str] || WeatherIcon.unknown;\n            if (symbol === WeatherIcon.unknown) {\n                console.warn(\"Unknown symbol\", symbol_str)\n            }\n\n            const weather: IWeather = {\n                temperature: timeobj.data.instant.details.air_temperature,\n                wind: timeobj.data.instant.details.wind_speed,\n                gust: NaN,\n                symbol: this.icons[symbol_str] || WeatherIcon.unknown,\n            }\n\n            forecast.weatherPoints.push({ time: date, weather: weather })\n        }\n\n        return forecast;\n    }\n}","import { METHODS } from \"http\";\nimport { ILocation } from \"../store/types\";\nimport { IForecast, IWeatherProvider } from \"./types\";\nimport MET from \"./weatherProviders/MET\";\nimport SMHI from \"./weatherProviders/SMHI\";\n\nconst weatherProviders: IWeatherProvider[] = [new SMHI(), new MET()]\n\n\nexport function getWeatherProviders(): IWeatherProvider[] {\n    return weatherProviders;\n}\n","import logo from '../../icons/provider logos/SMHI.jpg'\nimport { IForecast, IWeather, WeatherIcon } from \"../types\";\nimport AbstractProvider from \"./abstractProvider\";\n\n\nexport default class SMHI extends AbstractProvider {\n    constructor() {\n        super(\"SMHI\", logo)\n    }\n\n    private icons = {\n        1: WeatherIcon.clear_sky,          // Clear sky\n        2: WeatherIcon.nearly_clear_sky,   // Nearly clear sky\n        3: WeatherIcon.half_clear_sky,     // Variable cloudiness\n        4: WeatherIcon.half_clear_sky,     // Half clear sky\n        5: WeatherIcon.cloudy_sky,         // Cloudy sky\n        6: WeatherIcon.overcast,           // Overcast\n        18: WeatherIcon.light_rain,        // Light rain\n        19: WeatherIcon.moderate_rain,     // Moderate rain\n    }\n\n    protected async requestData(lat: string, long: string): Promise<Response> {\n        const max = 9; // the maximum precision allowed by the api (including decimal point)\n        const result = await fetch('https://opendata-download-metfcst.smhi.se/api/category/pmp3g/version/2/geotype/point/lon/'\n            + long.substr(0, max) + '/lat/' + lat.substr(0, max) + '/data.json');\n\n        if (!result.ok) {\n            throw new Error(\"Weather response error! status: ' + result.status\")\n        }\n\n        return result;\n    }\n\n    protected async formatResponse(response: Response): Promise<IForecast> {\n        let forecast: IForecast = {\n            weatherPoints: [],\n        }\n\n        const json = await response.json();\n\n        const timeSeries: [] = json['timeSeries'];\n\n        const currentDateTime = new Date().getTime();\n\n        timeSeries.forEach((time: any) => {\n            // Get the time:\n            const date = new Date(time['validTime']);\n\n            if (date.getTime() >= currentDateTime) {\n                // Get the weather for this time:\n\n                // Weather parameter descriptions can be found at:\n                // https://opendata.smhi.se/apidocs/metfcst/parameters.html#parameter-table\n\n                const parameters: [] = time['parameters']\n\n                const weather: IWeather = {\n                    temperature: NaN,\n                    wind: NaN,\n                    gust: NaN,\n                    symbol: WeatherIcon.unknown,\n                }\n\n                // TODO: Optimize. Don't loop through all parameters.\n                parameters.forEach(parameter => {\n                    const value = parameter['values'][0];\n                    switch (parameter['name']) {\n                        case 't':\n                            weather.temperature = value;\n                            break;\n                        case 'ws':\n                            weather.wind = value;\n                            break;\n                        case 'gust':\n                            weather.gust = value;\n                            break;\n                        case 'Wsymb2':\n                            let icon = this.icons[value];\n                            if (!icon) {\n                                console.warn(\"Unknown symbol value\", value)\n                                weather.symbol = WeatherIcon.unknown;\n                                break;\n                            }\n                            weather.symbol = this.icons[value];\n                            break;\n                    }\n                });\n\n                forecast.weatherPoints.push({ time: date, weather: weather });\n            }\n        });\n\n        return forecast;\n    }\n}","import { ForecastActionTypes, FORECAST_FETCH_START, FORECAST_FETCH_SUCCESS, FORECAST_FETCH_FAILURE, SET_DISPLAY_TIMES } from \"./types\";\nimport { ILocation } from \"../types\";\nimport { Dispatch } from \"redux\";\nimport { getWeatherProviders } from \"../../weather\";\nimport { IForecast, IWeatherProvider } from \"../../weather/types\";\n\nfunction searchStart(provider: IWeatherProvider): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_START,\n        provider: provider\n    }\n}\n\nfunction searchSuccess(provider: IWeatherProvider, forecast: IForecast): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_SUCCESS,\n        forecast: forecast,\n        provider: provider\n    }\n}\n\nfunction searchFailure(provider: IWeatherProvider, errorMessage: string): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_FAILURE,\n        errorMessage: errorMessage,\n        provider: provider\n    }\n}\n\nexport const fetchForecasts = (location: ILocation) => async (dispatch: Dispatch) => {\n    const onSuccess = (provider: IWeatherProvider, result: IForecast) => dispatch(searchSuccess(provider, result));\n    const onFailure = (provider: IWeatherProvider, error: Error) => dispatch(searchFailure(provider, error.message));\n\n    const providers = getWeatherProviders();\n\n    providers.forEach(provider => {\n        dispatch(searchStart(provider));\n        provider.fetchForecast(location, (result: IForecast) => onSuccess(provider, result), (error: Error) => onFailure(provider, error));\n    });\n\n}\n\nexport function setDisplayTimes(displayTimes: Date[]) {\n    return {\n        type: SET_DISPLAY_TIMES,\n        displayTimes: displayTimes\n    };\n}\n","import React from \"react\";\nimport CSS from 'csstype'\n\nimport './style.css';\n\ninterface Props {\n    style?: CSS.Properties,\n    children?: React.ReactNode\n}\n\nconst Paper = (props: Props) => (\n    <div className=\"paper\" style={props.style}>\n        {props.children}\n    </div>\n);\n\nexport default Paper;","import React from \"react\";\nimport { Typography } from \"antd\";\n\nimport './style.css';\nimport { IWeather } from \"../../../weather/types\";\n\nconst { Text } = Typography;\n\ninterface Props {\n    weather: IWeather\n}\n\nconsole.log(require(\"../../../icons/weather symbols/day_\" + \"clear_sky\" + \".svg\"))\n\nconst WeatherCell = (props: Props) => (\n    <div className=\"weather_cell\">\n        {props.weather != undefined &&\n            <React.Fragment>\n                <Text strong>{Math.round(props.weather.temperature)} °C</Text>\n                {props.weather.symbol &&\n                    <img className='weather_symbol' src={require(\"../../../icons/weather symbols/day_\" + props.weather.symbol + \".svg\").default} />\n                }\n                <div>\n                    <Text strong>{Math.round(props.weather.wind)}</Text>\n                    <Text type=\"secondary\"> ({Math.round(props.weather.gust)}) </Text>\n                    <Text strong>m/s</Text>\n                </div>\n            </React.Fragment>\n        }\n    </div>\n);\n\n\nexport default WeatherCell;","import React from \"react\";\nimport { Typography } from \"antd\";\n\nimport './style.css';\n\nconst { Text } = Typography;\n\ninterface Props {\n    time: Date\n}\n\nconst TimeCell = (props: Props) => (\n    <div className=\"time_cell\">\n        <Text strong>{('0' + props.time.getHours()).slice(-2)}</Text>\n    </div>\n);\n\nexport default TimeCell;","import React from \"react\";\nimport Paper from \"../../atoms/Paper\";\nimport WeatherCell from \"../WeatherCell\";\nimport { Divider, Typography } from \"antd\";\nimport TimeCell from \"../TimeCell\";\nimport { IForecast, IWeather } from \"../../../weather/types\";\nimport './style.css';\nimport { ITableData } from \"./types\";\n\ninterface IWeatherTableListProps {\n    tableData: ITableData,\n    name: string,\n}\n\nclass WeatherTable extends React.Component<IWeatherTableListProps> {\n    public render() {\n        return (\n            <div>\n                {this.props.name}\n                <div className=\"columns\">\n\n                    {/* Time row background */}\n                    <div className=\"right-column\">\n                        <div className=\"time-row\" style={{ width: '100%' }}>\n                            <Paper style={{ width: '100%', height: '100%' }} />\n                        </div>\n                    </div>\n\n                    {/* Weather row background. One for each provider. */}\n                    <div className=\"all-columns\">\n                        <div className=\"time-row\" />\n                        {this.props.tableData.providers.map((ignored, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Paper style={{ width: '100%', height: '100%' }} />\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Provider Name */}\n                    <div className=\"left-column\">\n                        <div className=\"time-row\" />\n                        {this.props.tableData.providers.map((provider, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Typography className=\"weather-provider-name\">\n                                    {provider.name}\n                                </Typography>\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Divider */}\n                    <div className=\"divider-column\">\n                        <div className=\"time-row\" />\n                        {this.props.tableData.providers.map((ignored, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Divider type=\"vertical\" style={{ height: 'calc(100% - 5px)', margin: 0 }} />\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Time cells and Weather cells */}\n                    <div className=\"right-column\" style={{ overflowX: 'auto' }}>\n                        <div className=\"time-row\">\n                            {this.props.tableData.columns.map((column, index) =>\n                                <TimeCell key={index} time={column.date} />\n                            )}\n                        </div>\n                        {this.props.tableData.providers.map((provider, index) =>\n                            <div key={index} className=\"weather-row\">\n                                {this.props.tableData.columns.map((column, index) =>\n                                    <WeatherCell key={index} weather={column.weatherMap.get(provider) as IWeather} />\n                                )}\n                            </div>\n                        )}\n                    </div>\n                </div >\n            </div>\n        );\n    }\n}\n\nexport default WeatherTable;","/**\n * Returns a list of Date objects with one hour difference, starting with the current hour.\n * @param count The number of Date objects to return.\n */\nexport function listHoursFromNow(count: number): Date[] {\n    let start = new Date();\n    start.setHours(start.getHours() + 1);\n    start.setMinutes(0);\n    start.setSeconds(0);\n    start.setMilliseconds(0);\n    return listDates(start, 3600000, count);\n}\n\n/**\n * Returns a list of Date objects with one day difference, the first day will\n * be at the current hour and following days will be at the 12th hour.\n * @param count The number of Date objects to return.\n */\nexport function listDaysFromNow(count: number): Date[] {\n    let first = new Date();\n    first.setHours(first.getHours() + 1);\n    first.setMinutes(0);\n    first.setSeconds(0);\n    first.setMilliseconds(0);\n\n    let start = new Date(first.getTime());\n    start.setHours(12);\n    start.setDate(start.getDate() + 1);\n\n    return [start, ...listDates(start, 86400000, count - 1)];\n}\n\n/**\n * Returns an array of Date objects.\n * @param start The first date in the array.\n * @param interval The time difference in milliseconds.\n * @param count The number of Date objects to return.\n */\nexport function listDates(start: Date, interval: number, count: number): Date[] {\n    let times: Date[] = []\n\n    for (let i = 0; i < count; i++) {\n        times.push(new Date(start.getTime() + (i * interval)));\n    }\n\n    return times;\n}\n\n/**\n * Returns the number of days from today to the given date.\n */\nexport function getDayOffset(date: Date) {\n    let today = new Date();\n    today.setHours(0);\n    today.setMinutes(0);\n    today.setSeconds(0);\n    today.setMilliseconds(0);\n\n    let diff = date.getTime() - today.getTime();\n\n    return Math.floor(diff / 86400000);  // 86400000 milliseconds in a day)\n}","import React from \"react\";\nimport './style.css';\nimport { IWeatherStateForecast } from \"../../../store/forecasts/types\";\nimport WeatherTable from \"../WeatherTable\";\nimport { getDayOffset, listHoursFromNow } from \"../../../helpers/date\";\nimport { ITableData } from \"../WeatherTable/types\";\nimport { table } from \"console\";\nimport { IWeather } from \"../../../weather/types\";\nimport { resolveSoa } from \"dns/promises\";\n\ninterface IWeatherTableListProps {\n    weatherStateForecasts: IWeatherStateForecast[],\n}\n\nexport default class WeatherTableList extends React.Component<IWeatherTableListProps> {\n\n    /**\n     * Converts the data from props to data accepted by the weather tables.\n     * @returns Array with table data.\n     */\n    private getTableData(): ITableData[] {\n        const result: ITableData[] = [];\n\n        const stateForecasts = this.props.weatherStateForecasts;\n        const providers = stateForecasts.map(stateForecast => { return stateForecast.weatherProvider });\n\n        // For every provider\n        for (let i = 0; i < stateForecasts.length; i++) {\n            const stateForecast = stateForecasts[i];\n\n            if (stateForecast.loading) {\n                continue;\n            }\n\n            // For every weather point\n            for (let j = 0; j < stateForecast.forecast.weatherPoints.length; j++) {\n                const weatherPoint = stateForecast.forecast.weatherPoints[j];\n\n                // Sometimes the date is a string because the reducer is bad.\n                let weatherPointDate: Date;\n                if (typeof weatherPoint.time === 'string')\n                    weatherPointDate = new Date(weatherPoint.time);\n                else\n                    weatherPointDate = weatherPoint.time\n\n                const dayOffset = getDayOffset(weatherPointDate);\n\n                if (dayOffset < 0) {\n                    console.warn(\"Old weather data\");\n                    continue;\n                }\n\n                // Create new table if needed\n                if (dayOffset >= result.length) {\n                    result.push({\n                        columns: [],\n                        providers: providers,\n                    })\n                }\n\n                const tableData = result[dayOffset];\n                const time = weatherPointDate.getTime();\n\n                // If no columns, add one\n                if (tableData.columns.length === 0) {\n                    tableData.columns.push({\n                        date: weatherPointDate,\n                        weatherMap: new Map(),\n                    })\n                }\n\n                // Create new column if needed, and add data.\n                for (let k = tableData.columns.length - 1; k >= 0; k--) {\n                    const column = tableData.columns[k];\n                    const columnTime = column.date.getTime();\n\n                    // Column already exists\n                    if (columnTime === time) {\n                        // Add data\n                        column.weatherMap.set(stateForecast.weatherProvider, weatherPoint.weather);\n                        break;\n                    }\n                    // Column should be after this column\n                    else if (columnTime < time) {\n                        // Add column\n                        tableData.columns.splice(k + 1, 0, {\n                            date: weatherPointDate,\n                            weatherMap: new Map(),\n                        })\n\n                        // Make sure that the data gets added in the next loop.\n                        k += 2;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private getTableName(index: number, date: Date | undefined): string {\n        let result = \"\";\n\n        if (!date) return result;\n\n        switch (index) {\n            case 0:\n                result += \"Idag, \";\n                break;\n            case 1:\n                result += \"Imorgon, \"\n        }\n\n        switch (date.getDay()) {\n            case 1:\n                result += \"Måndag\";\n                break;\n            case 2:\n                result += \"Tisdag\";\n                break;\n            case 3:\n                result += \"Onsdag\";\n                break;\n            case 4:\n                result += \"Torsdag\";\n                break;\n            case 5:\n                result += \"Fredag\";\n                break;\n            case 6:\n                result += \"Lördag\";\n                break;\n            case 0:\n                result += \"Söndag\";\n                break;\n        }\n\n        return result;\n    }\n\n    public render() {\n        let tableData = this.getTableData();\n\n        return (\n            <div className=\"list\">\n                {tableData.map((data, index) =>\n                    <WeatherTable key={index} tableData={data} name={this.getTableName(index, data.columns.length ? data.columns[0].date : undefined)} />\n                )}\n            </div>\n        );\n    }\n}\n","import { ILocation } from \"../types\";\n\nexport interface ILocationSearchState {\n    selectedLocation?: ILocation,\n    searchResults: ILocation[],\n    isLoading: boolean,\n    errorMessage: string,\n    userLocation?: ILocation,\n}\n\nexport const UPDATE_USER_LOCATION = 'UPDATE_USER_LOCATION';\n\ninterface IUpdateUserLocationAction {\n    type: typeof UPDATE_USER_LOCATION,\n    location?: ILocation\n}\n\nexport const SELECT_LOCATION = 'SELECT_LOCATION';\n\ninterface ISelectLocationAction {\n    type: typeof SELECT_LOCATION,\n    selectedLocation: ILocation\n}\n\nexport const SEARCH_START = 'SEARCH_START';\n\ninterface ISearchStartAction {\n    type: typeof SEARCH_START,\n}\n\nexport const SEARCH_SUCCESS = 'SEARCH_SUCCESS';\n\ninterface ISearchSuccessAction {\n    type: typeof SEARCH_SUCCESS,\n    results: ILocation[]\n}\n\nexport const SEARCH_FAILURE = 'SEARCH_FAILURE';\n\ninterface ISearchFailureAction {\n    type: typeof SEARCH_FAILURE,\n    errorMessage: string\n}\n\nexport type LocationSearchActionTypes = IUpdateUserLocationAction | ISelectLocationAction | ISearchStartAction | ISearchSuccessAction | ISearchFailureAction;","import { LocationSearchActionTypes, SEARCH_START, SEARCH_SUCCESS, SEARCH_FAILURE, SELECT_LOCATION, UPDATE_USER_LOCATION } from './types';\nimport { Dispatch } from 'redux';\nimport { ILocation } from '../types';\n\n\nconst minSearchDelay: number = 1000;\nvar nextSearchTime: number = Date.now();\nvar lastSearch: String = \"\"\n\n\nexport function updateUserLocation(location?: ILocation): LocationSearchActionTypes {\n    return {\n        type: UPDATE_USER_LOCATION,\n        location: location\n    }\n}\n\nexport function selectLocation(location: ILocation): LocationSearchActionTypes {\n    return {\n        type: SELECT_LOCATION,\n        selectedLocation: location\n    }\n}\n\nfunction searchStart(): LocationSearchActionTypes {\n    return {\n        type: SEARCH_START,\n    };\n}\n\nfunction searchSuccess(results: ILocation[]): LocationSearchActionTypes {\n    return {\n        type: SEARCH_SUCCESS,\n        results: results\n    }\n}\n\nfunction searchFailure(errorMessage: string): LocationSearchActionTypes {\n    return {\n        type: SEARCH_FAILURE,\n        errorMessage: errorMessage\n    }\n}\n\nexport const search = (searchTerm: string) => async (dispatch: Dispatch) => {\n    const trimmed = searchTerm.trim()\n    if (trimmed === lastSearch) {\n        return;\n    }\n\n    lastSearch = trimmed;\n\n    dispatch(searchStart());\n\n    nextSearchTime = Date.now() + minSearchDelay;\n    setTimeout(() => tryPerformSearch(searchTerm, dispatch), minSearchDelay + 1) // Add 1 for extra marginal\n}\n\n/**\n * Tries to perform a search, but cancels if the search time has moved.\n */\nfunction tryPerformSearch(searchTerm: string, dispatch: Dispatch) {\n    if (Date.now() < nextSearchTime) {\n        return;\n    }\n\n    performSearch(searchTerm, dispatch);\n}\n\nasync function performSearch(searchTerm: string, dispatch: Dispatch) {\n    const key = process.env.REACT_APP_LOCATIONIQ;\n    const address = \"https://api.locationiq.com/v1/autocomplete.php\";\n\n    const result = await fetch(`${address}?key=${key}&q=${searchTerm}&accept-language=sv`);//&accept-language=native');\n\n    const json = await result.json();\n\n    if (result.ok) {\n        const locations = toILocations(json);\n        dispatch(searchSuccess(locations));\n    }\n    // Returns this with a 404 status when no location found.\n    else if ( json['error'] == \"Unable to geocode\" ) {\n        const locations: ILocation[] = [];\n        dispatch(searchSuccess(locations))\n    }\n    else {\n        console.error('Geocode response error! status: ' + result.statusText);\n        dispatch(searchFailure(result.status.toString()));\n    }\n}\n\n// Converts JSON data from locationIQ to an ILocation array\nfunction toILocations(json: any): ILocation[] {\n    const locations: ILocation[] = []\n\n    try {\n        for (const loc of json) {\n            locations.push({\n                country: loc['display_address'],\n                name: loc['display_place'],\n                lat: Number(loc['lat']),\n                long: Number(loc['lon']),\n                alt: 0,\n            });\n        }\n\n        console.log(locations)\n        return locations\n    }\n    catch (error) {\n        console.error(error.message)\n        return []\n    }\n}\n","import React from \"react\";\nimport { Select, Typography, Spin } from 'antd';\nimport { connect } from 'react-redux';\nimport { AppState } from \"../../../store\";\nimport { search, selectLocation, updateUserLocation } from \"../../../store/locationSearch/actions\";\nimport { ILocation } from \"../../../store/types\";\nimport { fetchForecasts } from \"../../../store/forecasts/actions\";\n\nconst { Option } = Select;\nconst { Text } = Typography;\n\ninterface ISearchPageProps {\n    style?: React.CSSProperties,\n    selectedLocation?: ILocation,\n    isLoading: boolean,\n    errorMessage: string\n    locationResults: ILocation[],\n    selectLocation: (location: ILocation) => void,\n    searchLocations: (searchTerm: string) => void,\n    fetchForecasts: (location: ILocation) => void,\n    updateUserLocation: (location?: ILocation) => void,\n}\n\ninterface ISearchPageState {\n    searchText: string,\n}\n\nclass SearchBox extends React.Component<ISearchPageProps, ISearchPageState> {\n    constructor(props: Readonly<ISearchPageProps>) {\n        super(props);\n\n        this.state = {\n            searchText: \"\",\n        }\n\n        this.handleTextChange = this.handleTextChange.bind(this);\n    }\n\n    componentDidMount() {\n        // Get the user location\n        // TODO: Move this somewhere else\n        navigator.geolocation.getCurrentPosition(pos => {\n            const userLocation: ILocation = {\n                country: '',\n                name: 'Your Location',\n                lat: pos.coords.latitude,\n                long: pos.coords.longitude,\n                alt: pos.coords.altitude ? pos.coords.altitude : 0\n            };\n            // update user location\n            this.props.updateUserLocation(userLocation);\n            // select user location\n            this.props.selectLocation(userLocation);\n            // fetch forecast for user location\n            this.props.fetchForecasts(userLocation);\n        }, error => {\n            // user location error\n            // this.props.updateUserLocation(undefined)\n        });\n    }\n\n    private handleTextChange(value: string): void {\n        this.setState({\n            ...this.state,\n            searchText: value,\n        })\n    }\n\n    private handleSearch(value: string): void {\n        if (!value) return;\n        this.props.searchLocations(value);\n    }\n\n    private handleSelect(value: string): void {\n        const results = this.props.locationResults;\n        for (let i = 0; i < results.length; i++) {\n            if (results[i].name === value) {\n                this.props.selectLocation(results[i])\n                this.props.fetchForecasts(results[i])\n                break;\n            }\n        }\n    }\n\n    public render() {\n        let options: JSX.Element[] = [];\n\n        // Loading\n        if (this.props.isLoading)\n            options.push(CreateOption(<Spin />, \"spin\", 0));\n        else {\n            // Response error\n            if (this.props.errorMessage) {\n                options.push(CreateOption(\n                    <Text type=\"danger\">Error! Response status: {this.props.errorMessage}</Text>,\n                    \"error\", 0\n                ));\n            }\n            else {\n\n                // No locations found\n                if (this.props.locationResults.length === 0)\n                    options.push(CreateOption(<Text>No locations found.</Text>, \"no locations\", 0));\n                // Locations found\n                else {\n                    const locations = this.props.locationResults;\n\n                    for (let i = 0; i < locations.length; i++) {\n                        const location = locations[i]\n\n                        options.push(CreateOption(\n                            <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"space-between\" }}>\n                                <Text strong>{location.name}  </Text>\n                                {<Text type=\"secondary\">{location.country}</Text>}\n                            </div>,\n                            location.name,\n                            i\n                        ))\n                    }\n                }\n            }\n        }\n\n        return (\n            <Select\n                showSearch\n                style={this.props.style}\n                value={this.state.searchText ? this.state.searchText : undefined} // the placeholder only shows when value=undefined\n                placeholder=\"Sök\"\n                size=\"large\"\n                defaultActiveFirstOption={false}\n                showArrow={false}\n                filterOption={false}\n                onSearch={value => this.handleSearch(value)}\n                onChange={value => this.handleTextChange(value)}\n                onSelect={value => this.handleSelect(value)}\n                notFoundContent={null}\n            >\n                {options}\n            </Select>\n        );\n    }\n}\n\nfunction CreateOption(content: JSX.Element, value: string, key: any): JSX.Element {\n    return (\n        <Option value={value} key={key}>\n            {content}\n        </Option>\n    );\n}\n\nfunction mapStateToProps(state: AppState) {\n    return {\n        selectedLocation: state.locationSearch.selectedLocation,\n        locationResults: state.locationSearch.searchResults,\n        isLoading: state.locationSearch.isLoading,\n        errorMessage: state.locationSearch.errorMessage\n    }\n}\n\nfunction mapDispatchToProps(dispatch: any) { // TODO: Fix any type\n    return {\n        selectLocation: (location: ILocation) => dispatch(selectLocation(location)),\n        searchLocations: (searchTerm: string) => dispatch(search(searchTerm)),\n        fetchForecasts: (location: ILocation) => dispatch(fetchForecasts(location)),\n        updateUserLocation: (location?: ILocation) => dispatch(updateUserLocation(location))\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(SearchBox);","import React from \"react\";\nimport WeatherView from \"../weather/WeatherTemplate\";\nimport { connect } from \"react-redux\";\nimport { AppState } from \"../../store\";\nimport { ILocation } from \"../../store/types\";\nimport { setDisplayTimes } from \"../../store/forecasts/actions\";\nimport { listHoursFromNow, listDaysFromNow } from \"../../helpers/date\";\nimport { IWeatherStateForecast } from \"../../store/forecasts/types\";\nimport WeatherTableList from \"../weather/WeatherTableList\";\nimport SearchBox from \"../atoms/SearchBox\";\n\ninterface IWeatherPageProps {\n    location?: ILocation,\n    displayTimes: Date[],\n    weatherStateForecasts: IWeatherStateForecast[],\n    setDisplayTimes: (times: Date[]) => void,\n}\n\ninterface IWeatherPageState {\n}\n\nclass WeatherPage extends React.Component<IWeatherPageProps, IWeatherPageState>{\n    render() {\n        console.log(\"Render!!\")\n        return (\n            <div>\n                <SearchBox style={{width: \"100%\"}}/>\n                <WeatherTableList weatherStateForecasts={this.props.weatherStateForecasts} />\n            </div>\n        );\n    }\n}\n\nfunction mapStateToProps(state: AppState) {\n    return {\n        location: state.locationSearch.selectedLocation,\n        displayTimes: state.forecasts.displayTimes,\n        weatherStateForecasts: state.forecasts.weatherStateForecasts,\n    }\n}\n\nfunction mapDispatchToProps(dispatch: any) { // TODO: Fix any type\n    return {\n        setDisplayTimes: (time: Date[]) => dispatch(setDisplayTimes(time)),\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(WeatherPage);","import React, { Dispatch } from 'react';\nimport './App.css';\nimport SearchBox from './components/atoms/SearchBox';\nimport WeatherPage from './components/pages/WeatherPage';\nimport Header from './components/organisms/Header';\n\nfunction App() {\n  return (\n    <div id=\"app\">\n      <div className=\"page\">\n        <WeatherPage />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { ILocationSearchState, LocationSearchActionTypes, SEARCH_START, SEARCH_SUCCESS, SEARCH_FAILURE, SELECT_LOCATION, UPDATE_USER_LOCATION } from './types';\n\nconst initialState: ILocationSearchState = {\n    selectedLocation: undefined,\n    searchResults: [],\n    isLoading: false,\n    errorMessage: '',\n    userLocation: undefined\n}\n\nexport function locationSearchReducer(state = initialState, action: LocationSearchActionTypes): ILocationSearchState {\n    switch (action.type) {\n        case UPDATE_USER_LOCATION:\n            return {\n                ...state,\n                userLocation: action.location\n            };\n        case SELECT_LOCATION:\n            return {\n                ...state,\n                selectedLocation: action.selectedLocation\n            };\n        case SEARCH_START:\n            return {\n                ...state,\n                isLoading: true\n            };\n        case SEARCH_SUCCESS:\n            return {\n                ...state,\n                isLoading: false,\n                searchResults: action.results,\n                errorMessage: \"\",\n            }\n        case SEARCH_FAILURE:\n            return {\n                ...state,\n                isLoading: false,\n                searchResults: [],\n                errorMessage: action.errorMessage\n            };\n        default:\n            return state;\n    }\n}","import { IWeatherState as IForecastState, ForecastActionTypes, FORECAST_FETCH_START, FORECAST_FETCH_SUCCESS, FORECAST_FETCH_FAILURE, SET_DISPLAY_TIMES, IWeatherStateForecast } from \"./types\";\nimport { listHoursFromNow } from \"../../helpers/date\";\nimport { getWeatherProviders } from \"../../weather\";\n\nconst initialState: IForecastState = {\n    weatherStateForecasts: createInitialForecasts(),\n    displayTimes: listHoursFromNow(24),\n    nothing: 1,\n}\n\nexport function forecastReducer(state = initialState, action: ForecastActionTypes): IForecastState {\n    switch (action.type) {\n        case FORECAST_FETCH_START:\n            console.log(\"Fetch start!!\")\n\n            var newWeatherStateForecasts: IWeatherStateForecast[] = JSON.parse(JSON.stringify(state.weatherStateForecasts));\n\n            var weatherStateForecast = newWeatherStateForecasts.find(element => element.weatherProvider.name === action.provider.name);\n            if (weatherStateForecast !== undefined) {\n                weatherStateForecast.loading = true;\n            }\n\n            return {\n                ...state,\n                weatherStateForecasts: newWeatherStateForecasts,\n            };\n\n        case FORECAST_FETCH_SUCCESS:\n            console.log(\"Fetch success!!\");\n\n            var newWeatherStateForecasts: IWeatherStateForecast[] = JSON.parse(JSON.stringify(state.weatherStateForecasts));\n\n            var weatherStateForecast = newWeatherStateForecasts.find(element => element.weatherProvider.name === action.provider.name);\n            if (weatherStateForecast !== undefined) {\n                weatherStateForecast.loading = false;\n                weatherStateForecast.forecast = action.forecast;\n            }\n\n            return {\n                ...state,\n                weatherStateForecasts: newWeatherStateForecasts,\n            };\n\n        case FORECAST_FETCH_FAILURE:\n            console.log(\"Fetch fail\")\n\n            // TODO: Implement\n\n            return { ...state }\n\n        case SET_DISPLAY_TIMES:\n            // TODO: remove?\n            return state;\n\n        default:\n            return state;\n    }\n}\n\nfunction createInitialForecasts(): IWeatherStateForecast[] {\n    let forecasts: IWeatherStateForecast[] = []\n    const providers = getWeatherProviders();\n\n    providers.forEach(provider => {\n        let forecast: IWeatherStateForecast = {\n            weatherProvider: provider,\n            loading: true,\n            forecast: {\n                weatherPoints: []\n            }\n        }\n        forecasts.push(forecast)\n    });\n\n    console.log(\"Initial forecasts:\", forecasts)\n\n    return forecasts;\n}\n","import { createStore, compose, combineReducers, applyMiddleware } from \"redux\";\nimport { locationSearchReducer } from \"./locationSearch/reducers\";\nimport thunk from 'redux-thunk';\nimport { forecastReducer } from \"./forecasts/reducers\";\n\nconst rootReducer = combineReducers({\n    locationSearch: locationSearchReducer,\n    forecasts: forecastReducer\n});\n\ndeclare global {\n    interface Window {\n        __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n    }\n}\n\nconst initialState = {}\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nexport default createStore(\n    rootReducer,\n    initialState,\n    compose(\n        applyMiddleware(thunk),\n        composeEnhancers()\n    )\n);\n\nexport type AppState = ReturnType<typeof rootReducer>\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport store from \"./store\";\nimport { Provider } from 'react-redux';\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}