{"version":3,"sources":["icons/weather symbols/day_clear_sky.svg","icons/weather symbols sync /^/.//day_.*/.svg$","icons/weather symbols/day_cloudy_sky.svg","icons/weather symbols/day_half_clear_sky.svg","icons/weather symbols/day_light_rain.svg","icons/weather symbols/day_moderate_rain.svg","icons/weather symbols/day_moderate_rain_showers.svg","icons/weather symbols/day_moderate_sleet.svg","icons/weather symbols/day_nearly_clear_sky.svg","icons/weather symbols/day_overcast.svg","icons/weather symbols/day_thunder.svg","icons/weather symbols/day_thunderstorm.svg","icons/weather symbols/day_unknown.svg","weather/types.ts","store/forecasts/types.ts","icons/provider logos/SMHI.jpg","weather/weatherProviders/abstractProvider.ts","weather/weatherProviders/SMHI.ts","weather/weatherProviders/SMHI2.ts","weather/index.ts","store/forecasts/actions.ts","components/atoms/Paper/index.tsx","components/weather/WeatherCell/index.tsx","components/weather/TimeCell/index.tsx","components/weather/WeatherTable/index.tsx","helpers/date.ts","components/weather/WeatherTableList/index.tsx","store/locationSearch/types.ts","store/locationSearch/actions.ts","components/atoms/SearchBox/index.tsx","components/pages/WeatherPage.tsx","App.tsx","serviceWorker.ts","store/locationSearch/reducers.ts","store/forecasts/reducers.ts","store/index.ts","index.tsx"],"names":["map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","module","exports","WeatherIcon","FORECAST_FETCH_START","FORECAST_FETCH_SUCCESS","FORECAST_FETCH_FAILURE","SET_DISPLAY_TIMES","AbstractProvider","name","logo","this","location","onSuccess","onFailure","requestData","lat","toString","long","response","formatResponse","result","SMHI","icons","clear_sky","nearly_clear_sky","half_clear_sky","cloudy_sky","overcast","light_rain","moderate_rain","fetch","substr","ok","forecast","weatherPoints","json","forEach","time","date","Date","parameters","weather","temperature","NaN","wind","gust","symbol","unknown","parameter","value","console","warn","push","SMHI2","weatherProviders","getWeatherProviders","searchStart","provider","type","searchSuccess","searchFailure","errorMessage","Paper","props","className","style","children","Text","Typography","log","require","WeatherCell","undefined","Fragment","strong","Math","round","src","default","TimeCell","getHours","slice","WeatherTable","width","height","tableData","providers","ignored","index","margin","overflowX","Array","from","columns","timeMillis","column","weatherMap","get","React","Component","listDates","start","interval","count","times","i","getTime","WeatherTableList","days","stateForecasts","weatherStateForecasts","stateForecast","weatherProvider","loading","weatherTime","dayOffset","today","setHours","setMinutes","setSeconds","setMilliseconds","diff","floor","getDayOffset","length","Map","has","set","getDay","getTableData","data","getTableName","next","UPDATE_USER_LOCATION","SELECT_LOCATION","SEARCH_START","SEARCH_SUCCESS","SEARCH_FAILURE","nextSearchTime","now","lastSearch","results","tryPerformSearch","searchTerm","dispatch","performSearch","a","process","locations","toILocations","error","statusText","status","loc","country","Number","alt","message","Option","Select","SearchBox","state","searchText","handleTextChange","bind","navigator","geolocation","getCurrentPosition","pos","userLocation","coords","latitude","longitude","altitude","updateUserLocation","selectLocation","fetchForecasts","setState","searchLocations","locationResults","options","isLoading","CreateOption","display","flexDirection","justifyContent","showSearch","placeholder","size","defaultActiveFirstOption","showArrow","filterOption","onSearch","handleSearch","onChange","onSelect","handleSelect","notFoundContent","content","key","connect","selectedLocation","locationSearch","searchResults","trimmed","trim","setTimeout","minSearchDelay","search","fetchForecast","WeatherPage","displayTimes","forecasts","setDisplayTimes","App","Boolean","window","hostname","match","initialState","createInitialForecasts","listHoursFromNow","nothing","rootReducer","combineReducers","action","weatherStateForecast","newWeatherStateForecasts","JSON","parse","stringify","find","element","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","applyMiddleware","thunk","ReactDOM","render","store","document","getElementById","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.3fa82a01.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/day_clear_sky.3cec5a70.svg\";","var map = {\n\t\"./day_clear_sky.svg\": 105,\n\t\"./day_cloudy_sky.svg\": 210,\n\t\"./day_half_clear_sky.svg\": 211,\n\t\"./day_light_rain.svg\": 212,\n\t\"./day_moderate_rain.svg\": 213,\n\t\"./day_moderate_rain_showers.svg\": 214,\n\t\"./day_moderate_sleet.svg\": 215,\n\t\"./day_nearly_clear_sky.svg\": 216,\n\t\"./day_overcast.svg\": 217,\n\t\"./day_thunder.svg\": 218,\n\t\"./day_thunderstorm.svg\": 219,\n\t\"./day_unknown.svg\": 220\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 209;","export default __webpack_public_path__ + \"static/media/day_cloudy_sky.28c5a064.svg\";","export default __webpack_public_path__ + \"static/media/day_half_clear_sky.f2367887.svg\";","export default __webpack_public_path__ + \"static/media/day_light_rain.8de418d1.svg\";","export default __webpack_public_path__ + \"static/media/day_moderate_rain.1ac9a777.svg\";","export default __webpack_public_path__ + \"static/media/day_moderate_rain_showers.5bdbfbe3.svg\";","export default __webpack_public_path__ + \"static/media/day_moderate_sleet.b195ed64.svg\";","export default __webpack_public_path__ + \"static/media/day_nearly_clear_sky.9a7090ce.svg\";","export default __webpack_public_path__ + \"static/media/day_overcast.062fc05d.svg\";","export default __webpack_public_path__ + \"static/media/day_thunder.08acff3b.svg\";","export default __webpack_public_path__ + \"static/media/day_thunderstorm.fb8d6c57.svg\";","export default __webpack_public_path__ + \"static/media/day_unknown.d6ceac86.svg\";","import { ILocation } from \"../store/types\";\n\nexport interface IForecast {\n    weatherPoints: IWeatherTime[],\n}\n\nexport interface IWeatherTime {\n    time: Date,\n    weather: IWeather,\n}\n\nexport interface IWeather {\n    temperature: number,\n    wind: number,\n    gust: number,\n    symbol: WeatherIcon,\n}\n\nexport interface IWeatherProvider {\n    name: string;\n    logo: string;\n    fetchForecast(location: ILocation, onSuccess: (result: IForecast) => any, onFailure: (error: Error) => any): void;\n}\n\nexport enum WeatherIcon {\n    unknown = \"unknown\",\n    // Cloudiness\n    clear_sky = \"clear_sky\",\n    nearly_clear_sky = \"nearly_clear_sky\",\n    half_clear_sky = \"half_clear_sky\",\n    cloudy_sky = \"cloudy_sky\",\n    overcast = \"overcast\",\n    // Rain\n    light_rain = \"light_rain\",\n    moderate_rain = \"moderate_rain\",\n    heavy_rain = \"heavy_rain\",\n}","import { IForecast, IWeatherProvider } from \"../../weather/types\";\n\nexport interface IWeatherStateForecast {\n    weatherProvider: IWeatherProvider;\n    loading: boolean;\n    forecast: IForecast;\n}\n\nexport interface IWeatherState {\n    weatherStateForecasts: IWeatherStateForecast[],\n    displayTimes: Date[],\n    nothing: number,\n}\n\nexport const FORECAST_FETCH_START = 'FORECAST_FETCH_START';\n\ninterface IFetchStartAction {\n    type: typeof FORECAST_FETCH_START,\n    provider: IWeatherProvider\n}\n\nexport const FORECAST_FETCH_SUCCESS = 'FORECAST_FETCH_SUCCESS';\n\ninterface IFetchSuccessAction {\n    type: typeof FORECAST_FETCH_SUCCESS,\n    forecast: IForecast,\n    provider: IWeatherProvider\n}\n\nexport const FORECAST_FETCH_FAILURE = 'FORECAST_FETCH_FAILURE';\n\ninterface IFetchFailureAction {\n    type: typeof FORECAST_FETCH_FAILURE,\n    errorMessage: string,\n    provider: IWeatherProvider\n}\n\nexport const SET_DISPLAY_TIMES = 'SET_DISPLAY_TIMES';\n\ninterface ISetDisplayTimesAction {\n    type: typeof SET_DISPLAY_TIMES,\n    displayTimes: Date[]\n}\n\nexport type ForecastActionTypes = IFetchStartAction | IFetchSuccessAction | IFetchFailureAction | ISetDisplayTimesAction;","export default __webpack_public_path__ + \"static/media/SMHI.147242e8.jpg\";","import { ILocation } from \"../../store/types\";\nimport { IForecast, IWeatherProvider } from \"../types\";\n\nexport default abstract class AbstractProvider implements IWeatherProvider {\n    name: string;\n    logo: string;\n\n    constructor(name: string, logo: string) {\n        this.name = name;\n        this.logo = logo;\n    }\n\n    public async fetchForecast(location: ILocation, onSuccess: (result: IForecast) => any, onFailure: (error: Error) => any) {\n        let result: IForecast;\n\n        try {\n            // Send a request\n            let response = await this.requestData(location.lat.toString(), location.long.toString());\n\n            // Format the response \n            result = await this.formatResponse(response);\n\n        } catch (e) {\n            onFailure(e);\n            return;\n        }\n\n        onSuccess(result)\n    }\n\n    protected abstract requestData(lat: string, long: string): Promise<Response>;\n    protected abstract formatResponse(response: Response): Promise<IForecast>;\n}","import logo from '../../icons/provider logos/SMHI.jpg'\nimport { IForecast, IWeather, WeatherIcon } from \"../types\";\nimport AbstractProvider from \"./abstractProvider\";\n\n\nexport default class SMHI extends AbstractProvider {\n    constructor() {\n        super(\"SMHI\", logo)\n    }\n\n    private icons = {\n        1: WeatherIcon.clear_sky,          // Clear sky\n        2: WeatherIcon.nearly_clear_sky,   // Nearly clear sky\n        3: WeatherIcon.half_clear_sky,     // Variable cloudiness\n        4: WeatherIcon.half_clear_sky,     // Half clear sky\n        5: WeatherIcon.cloudy_sky,         // Cloudy sky\n        6: WeatherIcon.overcast,           // Overcast\n        18: WeatherIcon.light_rain,        // Light rain\n        19: WeatherIcon.moderate_rain,     // Moderate rain\n        //20: WeatherIcon.heavy_rain,        // Heavy rain\n    }\n\n    protected async requestData(lat: string, long: string): Promise<Response> {\n        const max = 9; // the maximum precision allowed by the api (including decimal point)\n        const result = await fetch('https://opendata-download-metfcst.smhi.se/api/category/pmp3g/version/2/geotype/point/lon/'\n            + long.substr(0, max) + '/lat/' + lat.substr(0, max) + '/data.json');\n\n        if (!result.ok) {\n            throw new Error(\"Weather response error! status: ' + result.status\")\n        }\n\n        return result;\n    }\n\n    protected async formatResponse(response: Response): Promise<IForecast> {\n        let forecast: IForecast = {\n            weatherPoints: [],\n        }\n\n        const json = await response.json();\n\n        const timeSeries: [] = json['timeSeries'];\n\n        timeSeries.forEach((time: any) => {\n            // Get the time:\n            const date = new Date(time['validTime']);\n\n            // Get the weather for this time:\n\n            // Weather parameter descriptions can be found at:\n            // https://opendata.smhi.se/apidocs/metfcst/parameters.html#parameter-table\n\n            const parameters: [] = time['parameters']\n\n            const weather: IWeather = {\n                temperature: NaN,\n                wind: NaN,\n                gust: NaN,\n                symbol: WeatherIcon.unknown,\n            }\n\n            // TODO: Optimize. Don't loop through all parameters.\n            parameters.forEach(parameter => {\n                const value = parameter['values'][0];\n                switch (parameter['name']) {\n                    case 't':\n                        weather.temperature = value;\n                        break;\n                    case 'ws':\n                        weather.wind = value;\n                        break;\n                    case 'gust':\n                        weather.gust = value;\n                        break;\n                    case 'Wsymb2':\n                        let icon = this.icons[value];\n                        if (!icon) {\n                            console.warn(\"Unknown symbol value\", value)\n                            weather.symbol = WeatherIcon.unknown;\n                            break;\n                        }\n                        weather.symbol = this.icons[value];\n                        break;\n                }\n            });\n\n            forecast.weatherPoints.push({ time: date, weather: weather });\n        });\n\n        return forecast;\n    }\n}","import logo from '../../icons/provider logos/SMHI.jpg'\nimport { IForecast, IWeather, WeatherIcon } from \"../types\";\nimport AbstractProvider from \"./abstractProvider\";\n\n\nexport default class SMHI2 extends AbstractProvider {\n    constructor() {\n        super(\"SMHI2\", logo)\n    }\n\n    private icons = {\n        1: WeatherIcon.clear_sky,          // Clear sky\n        2: WeatherIcon.nearly_clear_sky,   // Nearly clear sky\n        3: WeatherIcon.half_clear_sky,     // Variable cloudiness\n        4: WeatherIcon.half_clear_sky,     // Half clear sky\n        5: WeatherIcon.cloudy_sky,         // Cloudy sky\n        6: WeatherIcon.overcast,           // Overcast\n        18: WeatherIcon.light_rain,        // Light rain\n        19: WeatherIcon.moderate_rain,     // Moderate rain\n        //20: WeatherIcon.heavy_rain,        // Heavy rain\n    }\n\n    protected async requestData(lat: string, long: string): Promise<Response> {\n        const max = 9; // the maximum precision allowed by the api (including decimal point)\n        const result = await fetch('https://opendata-download-metfcst.smhi.se/api/category/pmp3g/version/2/geotype/point/lon/'\n            + long.substr(0, max) + '/lat/' + lat.substr(0, max) + '/data.json');\n\n        if (!result.ok) {\n            throw new Error(\"Weather response error! status: ' + result.status\")\n        }\n\n        return result;\n    }\n\n    protected async formatResponse(response: Response): Promise<IForecast> {\n        let forecast: IForecast = {\n            weatherPoints: [],\n        }\n\n        const json = await response.json();\n\n        const timeSeries: [] = json['timeSeries'];\n\n        timeSeries.forEach((time: any) => {\n            // Get the time:\n            const date = new Date(time['validTime']);\n\n            // Get the weather for this time:\n\n            // Weather parameter descriptions can be found at:\n            // https://opendata.smhi.se/apidocs/metfcst/parameters.html#parameter-table\n\n            const parameters: [] = time['parameters']\n\n            const weather: IWeather = {\n                temperature: NaN,\n                wind: NaN,\n                gust: NaN,\n                symbol: WeatherIcon.unknown,\n            }\n\n            // TODO: Optimize. Don't loop through all parameters.\n            parameters.forEach(parameter => {\n                const value = parameter['values'][0];\n                switch (parameter['name']) {\n                    case 't':\n                        weather.temperature = value;\n                        break;\n                    case 'ws':\n                        weather.wind = value;\n                        break;\n                    case 'gust':\n                        weather.gust = value;\n                        break;\n                    case 'Wsymb2':\n                        let icon = this.icons[value];\n                        if (!icon) {\n                            console.warn(\"Unknown symbol value\", value)\n                            break;\n                        }\n                        weather.symbol = this.icons[value];\n                        break;\n                }\n            });\n\n            forecast.weatherPoints.push({time: date, weather: weather});\n        });\n\n        return forecast;\n    }\n}","import { ILocation } from \"../store/types\";\nimport { IForecast, IWeatherProvider } from \"./types\";\nimport SMHI from \"./weatherProviders/SMHI\";\nimport SMHI2 from \"./weatherProviders/SMHI2\";\n\nconst weatherProviders: IWeatherProvider[] = [new SMHI(), new SMHI2()]\n\n\nexport function getWeatherProviders(): IWeatherProvider[] {\n    return weatherProviders;\n}\n","import { ForecastActionTypes, FORECAST_FETCH_START, FORECAST_FETCH_SUCCESS, FORECAST_FETCH_FAILURE, SET_DISPLAY_TIMES } from \"./types\";\nimport { ILocation } from \"../types\";\nimport { Dispatch } from \"redux\";\nimport { getWeatherProviders } from \"../../weather\";\nimport { IForecast, IWeatherProvider } from \"../../weather/types\";\n\nfunction searchStart(provider: IWeatherProvider): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_START,\n        provider: provider\n    }\n}\n\nfunction searchSuccess(provider: IWeatherProvider, forecast: IForecast): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_SUCCESS,\n        forecast: forecast,\n        provider: provider\n    }\n}\n\nfunction searchFailure(provider: IWeatherProvider, errorMessage: string): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_FAILURE,\n        errorMessage: errorMessage,\n        provider: provider\n    }\n}\n\nexport const fetchForecasts = (location: ILocation) => async (dispatch: Dispatch) => {\n    const onSuccess = (provider: IWeatherProvider, result: IForecast) => dispatch(searchSuccess(provider, result));\n    const onFailure = (provider: IWeatherProvider, error: Error) => dispatch(searchFailure(provider, error.message));\n\n    const providers = getWeatherProviders();\n\n    providers.forEach(provider => {\n        dispatch(searchStart(provider));\n        provider.fetchForecast(location, (result: IForecast) => onSuccess(provider, result), (error: Error) => onFailure(provider, error));\n    });\n\n}\n\nexport function setDisplayTimes(displayTimes: Date[]) {\n    return {\n        type: SET_DISPLAY_TIMES,\n        displayTimes: displayTimes\n    };\n}\n","import React from \"react\";\nimport CSS from 'csstype'\n\nimport './style.css';\n\ninterface Props {\n    style?: CSS.Properties,\n    children?: React.ReactNode\n}\n\nconst Paper = (props: Props) => (\n    <div className=\"paper\" style={props.style}>\n        {props.children}\n    </div>\n);\n\nexport default Paper;","import React from \"react\";\nimport { Typography } from \"antd\";\n\nimport './style.css';\nimport { IWeather } from \"../../../weather/types\";\n\nconst { Text } = Typography;\n\ninterface Props {\n    weather: IWeather\n}\n\nconsole.log(require(\"../../../icons/weather symbols/day_\" + \"clear_sky\" + \".svg\"))\n\nconst WeatherCell = (props: Props) => (\n    <div className=\"weather_cell\">\n        {props.weather != undefined &&\n            <React.Fragment>\n                <Text strong>{Math.round(props.weather.temperature)} °C</Text>\n                {props.weather.symbol &&\n                    <img className='weather_symbol' src={require(\"../../../icons/weather symbols/day_\" + props.weather.symbol + \".svg\").default} />\n                }\n                <div>\n                    <Text strong>{Math.round(props.weather.wind)}</Text>\n                    <Text type=\"secondary\"> ({Math.round(props.weather.gust)}) </Text>\n                    <Text strong>m/s</Text>\n                </div>\n            </React.Fragment>\n        }\n    </div>\n);\n\n\nexport default WeatherCell;","import React from \"react\";\nimport { Typography } from \"antd\";\n\nimport './style.css';\n\nconst { Text } = Typography;\n\ninterface Props {\n    time: Date\n}\n\nconst TimeCell = (props: Props) => (\n    <div className=\"time_cell\">\n        <Text strong>{('0' + props.time.getHours()).slice(-2)}</Text>\n    </div>\n);\n\nexport default TimeCell;","import React from \"react\";\nimport Paper from \"../../atoms/Paper\";\nimport WeatherCell from \"../WeatherCell\";\nimport { Divider, Typography } from \"antd\";\nimport TimeCell from \"../TimeCell\";\nimport { IForecast, IWeather } from \"../../../weather/types\";\nimport './style.css';\nimport { ITableData } from \"./types\";\n\ninterface IWeatherTableListProps {\n    tableData: ITableData,\n    name: string,\n}\n\nclass WeatherTable extends React.Component<IWeatherTableListProps> {\n    public render() {\n        return (\n            <div>\n                {this.props.name}\n                <div className=\"columns\">\n\n                    {/* Time row background */}\n                    <div className=\"right-column\">\n                        <div className=\"time-row\" style={{ width: '100%' }}>\n                            <Paper style={{ width: '100%', height: '100%' }} />\n                        </div>\n                    </div>\n\n                    {/* Weather row background. One for each provider. */}\n                    <div className=\"all-columns\">\n                        <div className=\"time-row\" />\n                        {this.props.tableData.providers.map((ignored, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Paper style={{ width: '100%', height: '100%' }} />\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Provider Name */}\n                    <div className=\"left-column\">\n                        <div className=\"time-row\" />\n                        {this.props.tableData.providers.map((provider, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Typography className=\"weather-provider-name\">\n                                    {provider.name}\n                                </Typography>\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Divider */}\n                    <div className=\"divider-column\">\n                        <div className=\"time-row\" />\n                        {this.props.tableData.providers.map((ignored, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Divider type=\"vertical\" style={{ height: 'calc(100% - 5px)', margin: 0 }} />\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Time cells and Weather cells */}\n                    <div className=\"right-column\" style={{ overflowX: 'auto' }}>\n                        <div className=\"time-row\">\n                            {Array.from(this.props.tableData.columns, ([timeMillis, column]) =>\n                                <TimeCell key={timeMillis} time={column.date} />\n                            )}\n                        </div>\n                        {this.props.tableData.providers.map((provider, index) =>\n                            <div key={index} className=\"weather-row\">\n                                {Array.from(this.props.tableData.columns, ([timeMillis, column]) =>\n                                    <WeatherCell key={timeMillis} weather={column.weatherMap.get(provider) as IWeather} />\n                                )}\n                            </div>\n                        )}\n                    </div>\n                </div >\n            </div>\n        );\n    }\n}\n\nexport default WeatherTable;","/**\n * Returns a list of Date objects with one hour difference, starting with the current hour.\n * @param count The number of Date objects to return.\n */\nexport function listHoursFromNow(count: number): Date[] {\n    let start = new Date();\n    start.setHours(start.getHours() + 1);\n    start.setMinutes(0);\n    start.setSeconds(0);\n    start.setMilliseconds(0);\n    return listDates(start, 3600000, count);\n}\n\n/**\n * Returns a list of Date objects with one day difference, the first day will\n * be at the current hour and following days will be at the 12th hour.\n * @param count The number of Date objects to return.\n */\nexport function listDaysFromNow(count: number): Date[] {\n    let first = new Date();\n    first.setHours(first.getHours() + 1);\n    first.setMinutes(0);\n    first.setSeconds(0);\n    first.setMilliseconds(0);\n\n    let start = new Date(first.getTime());\n    start.setHours(12);\n    start.setDate(start.getDate() + 1);\n\n    return [start, ...listDates(start, 86400000, count - 1)];\n}\n\n/**\n * Returns an array of Date objects.\n * @param start The first date in the array.\n * @param interval The time difference in milliseconds.\n * @param count The number of Date objects to return.\n */\nexport function listDates(start: Date, interval: number, count: number): Date[] {\n    let times: Date[] = []\n\n    for (let i = 0; i < count; i++) {\n        times.push(new Date(start.getTime() + (i * interval)));\n    }\n\n    return times;\n}\n\n/**\n * Returns the number of days from today to the given date.\n */\nexport function getDayOffset(date: Date) {\n    let today = new Date();\n    today.setHours(0);\n    today.setMinutes(0);\n    today.setSeconds(0);\n    today.setMilliseconds(0);\n\n    let diff = date.getTime() - today.getTime();\n\n    return Math.floor(diff / 86400000);  // 86400000 milliseconds in a day)\n}","import React from \"react\";\nimport './style.css';\nimport { IWeatherStateForecast } from \"../../../store/forecasts/types\";\nimport WeatherTable from \"../WeatherTable\";\nimport { getDayOffset, listHoursFromNow } from \"../../../helpers/date\";\nimport { ITableData } from \"../WeatherTable/types\";\nimport { table } from \"console\";\nimport { IWeather } from \"../../../weather/types\";\nimport { resolveSoa } from \"dns/promises\";\n\ninterface IWeatherTableListProps {\n    weatherStateForecasts: IWeatherStateForecast[],\n}\n\nexport default class WeatherTableList extends React.Component<IWeatherTableListProps> {\n\n    private days = {\n        1: \"Måndag\",\n        2: \"Tisdag\",\n        3: \"Onsdag\",\n        4: \"Torsdag\",\n        5: \"Fredag\",\n        6: \"Lördag\",\n        7: \"Söndag\",\n    }\n\n    /**\n     * Converts the data from props to data accepted by the weather tables.\n     * @returns Array with table data.\n     */\n    private getTableData(): ITableData[] {\n        const result: ITableData[] = [];\n\n        const stateForecasts = this.props.weatherStateForecasts;\n        const providers = stateForecasts.map(stateForecast => { return stateForecast.weatherProvider });\n\n\n        // For every provider\n        // Loop through times\n        // Check which day\n        // Check is day exists in result\n        // Add data\n\n        stateForecasts.forEach(stateForecast => {\n            if (!stateForecast.loading) {\n                stateForecast.forecast.weatherPoints.forEach((weatherTime) => {\n\n                    // Sometimes the date is a string because the reducer is bad.\n                    let date: Date;\n                    if (typeof weatherTime.time === 'string')\n                        date = new Date(weatherTime.time);\n                    else\n                        date = weatherTime.time;\n\n                    const dayOffset = getDayOffset(date);\n\n                    if (dayOffset >= 0) {\n                        // Create new table if needed\n                        if (dayOffset >= result.length) {\n                            result.push({\n                                columns: new Map(),\n                                providers: providers,\n                            })\n                        }\n\n                        const tableData = result[dayOffset];\n\n                        const time = date.getTime();\n\n                        // Create new column if needed\n                        if (!tableData.columns.has(time)) {\n                            tableData.columns.set(time, {\n                                date: date,\n                                weatherMap: new Map(),\n                            })\n                        }\n\n                        tableData.columns.get(time)?.weatherMap.set(stateForecast.weatherProvider, weatherTime.weather);\n                    }\n                });\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Returns the number of time points there should be for a given day.\n     * @param dayOffset \n     */\n    private getTimePointCount(dayOffset: number): number {\n        return 24;\n    }\n\n    private getTableName(index: number, date: Date | undefined): string {\n        let result = \"\";\n\n        if (!date) return result;\n\n        switch (index) {\n            case 0:\n                result += \"Idag, \";\n                break;\n            case 1:\n                result += \"Imorgon, \"\n        }\n\n        switch (date.getDay()) {\n            case 1:\n                result += \"Måndag\";\n                break;\n            case 2:\n                result += \"Tisdag\";\n                break;\n            case 3:\n                result += \"Onsdag\";\n                break;\n            case 4:\n                result += \"Torsdag\";\n                break;\n            case 5:\n                result += \"Fredag\";\n                break;\n            case 6:\n                result += \"Lördag\";\n                break;\n            case 0:\n                result += \"Söndag\";\n                break;\n        }\n\n        return result;\n    }\n\n    public render() {\n        let tableData = this.getTableData();\n\n        return (\n            <div className=\"list\">\n                {tableData.map((data, index) =>\n                    <WeatherTable key={index} tableData={data} name={this.getTableName(index, data.columns.get(data.columns.keys().next().value)?.date)} />\n                )}\n            </div>\n        );\n    }\n}\n","import { ILocation } from \"../types\";\n\nexport interface ILocationSearchState {\n    selectedLocation?: ILocation,\n    searchResults: ILocation[],\n    isLoading: boolean,\n    errorMessage: string,\n    userLocation?: ILocation,\n}\n\nexport const UPDATE_USER_LOCATION = 'UPDATE_USER_LOCATION';\n\ninterface IUpdateUserLocationAction {\n    type: typeof UPDATE_USER_LOCATION,\n    location?: ILocation\n}\n\nexport const SELECT_LOCATION = 'SELECT_LOCATION';\n\ninterface ISelectLocationAction {\n    type: typeof SELECT_LOCATION,\n    selectedLocation: ILocation\n}\n\nexport const SEARCH_START = 'SEARCH_START';\n\ninterface ISearchStartAction {\n    type: typeof SEARCH_START,\n}\n\nexport const SEARCH_SUCCESS = 'SEARCH_SUCCESS';\n\ninterface ISearchSuccessAction {\n    type: typeof SEARCH_SUCCESS,\n    results: ILocation[]\n}\n\nexport const SEARCH_FAILURE = 'SEARCH_FAILURE';\n\ninterface ISearchFailureAction {\n    type: typeof SEARCH_FAILURE,\n    errorMessage: string\n}\n\nexport type LocationSearchActionTypes = IUpdateUserLocationAction | ISelectLocationAction | ISearchStartAction | ISearchSuccessAction | ISearchFailureAction;","import { LocationSearchActionTypes, SEARCH_START, SEARCH_SUCCESS, SEARCH_FAILURE, SELECT_LOCATION, UPDATE_USER_LOCATION } from './types';\nimport { Dispatch } from 'redux';\nimport { ILocation } from '../types';\n\n\nconst minSearchDelay: number = 1000;\nvar nextSearchTime: number = Date.now();\nvar lastSearch: String = \"\"\n\n\nexport function updateUserLocation(location?: ILocation): LocationSearchActionTypes {\n    return {\n        type: UPDATE_USER_LOCATION,\n        location: location\n    }\n}\n\nexport function selectLocation(location: ILocation): LocationSearchActionTypes {\n    return {\n        type: SELECT_LOCATION,\n        selectedLocation: location\n    }\n}\n\nfunction searchStart(): LocationSearchActionTypes {\n    return {\n        type: SEARCH_START,\n    };\n}\n\nfunction searchSuccess(results: ILocation[]): LocationSearchActionTypes {\n    return {\n        type: SEARCH_SUCCESS,\n        results: results\n    }\n}\n\nfunction searchFailure(errorMessage: string): LocationSearchActionTypes {\n    return {\n        type: SEARCH_FAILURE,\n        errorMessage: errorMessage\n    }\n}\n\nexport const search = (searchTerm: string) => async (dispatch: Dispatch) => {\n    const trimmed = searchTerm.trim()\n    if (trimmed === lastSearch) {\n        return;\n    }\n\n    lastSearch = trimmed;\n\n    dispatch(searchStart());\n\n    nextSearchTime = Date.now() + minSearchDelay;\n    setTimeout(() => tryPerformSearch(searchTerm, dispatch), minSearchDelay + 1) // Add 1 for extra marginal\n}\n\n/**\n * Tries to perform a search, but cancels if the search time has moved.\n */\nfunction tryPerformSearch(searchTerm: string, dispatch: Dispatch) {\n    if (Date.now() < nextSearchTime) {\n        return;\n    }\n\n    performSearch(searchTerm, dispatch);\n}\n\nasync function performSearch(searchTerm: string, dispatch: Dispatch) {\n    const key = process.env.REACT_APP_LOCATIONIQ;\n    const address = \"https://api.locationiq.com/v1/autocomplete.php\";\n\n    const result = await fetch(`${address}?key=${key}&q=${searchTerm}&accept-language=sv`);//&accept-language=native');\n\n    const json = await result.json();\n\n    if (result.ok) {\n        const locations = toILocations(json);\n        dispatch(searchSuccess(locations));\n    }\n    // Returns this with a 404 status when no location found.\n    else if ( json['error'] == \"Unable to geocode\" ) {\n        const locations: ILocation[] = [];\n        dispatch(searchSuccess(locations))\n    }\n    else {\n        console.error('Geocode response error! status: ' + result.statusText);\n        dispatch(searchFailure(result.status.toString()));\n    }\n}\n\n// Converts JSON data from locationIQ to an ILocation array\nfunction toILocations(json: any): ILocation[] {\n    const locations: ILocation[] = []\n\n    try {\n        for (const loc of json) {\n            locations.push({\n                country: loc['display_address'],\n                name: loc['display_place'],\n                lat: Number(loc['lat']),\n                long: Number(loc['lon']),\n                alt: 0,\n            });\n        }\n\n        console.log(locations)\n        return locations\n    }\n    catch (error) {\n        console.error(error.message)\n        return []\n    }\n}\n","import React from \"react\";\nimport { Select, Typography, Spin } from 'antd';\nimport { connect } from 'react-redux';\nimport { AppState } from \"../../../store\";\nimport { search, selectLocation, updateUserLocation } from \"../../../store/locationSearch/actions\";\nimport { ILocation } from \"../../../store/types\";\nimport { fetchForecasts } from \"../../../store/forecasts/actions\";\n\nconst { Option } = Select;\nconst { Text } = Typography;\n\ninterface ISearchPageProps {\n    style?: React.CSSProperties,\n    selectedLocation?: ILocation,\n    isLoading: boolean,\n    errorMessage: string\n    locationResults: ILocation[],\n    selectLocation: (location: ILocation) => void,\n    searchLocations: (searchTerm: string) => void,\n    fetchForecasts: (location: ILocation) => void,\n    updateUserLocation: (location?: ILocation) => void,\n}\n\ninterface ISearchPageState {\n    searchText: string,\n}\n\nclass SearchBox extends React.Component<ISearchPageProps, ISearchPageState> {\n    constructor(props: Readonly<ISearchPageProps>) {\n        super(props);\n\n        this.state = {\n            searchText: \"\",\n        }\n\n        this.handleTextChange = this.handleTextChange.bind(this);\n    }\n\n    componentDidMount() {\n        // Get the user location\n        // TODO: Move this somewhere else\n        navigator.geolocation.getCurrentPosition(pos => {\n            const userLocation: ILocation = {\n                country: '',\n                name: 'Your Location',\n                lat: pos.coords.latitude,\n                long: pos.coords.longitude,\n                alt: pos.coords.altitude ? pos.coords.altitude : 0\n            };\n            // update user location\n            this.props.updateUserLocation(userLocation);\n            // select user location\n            this.props.selectLocation(userLocation);\n            // fetch forecast for user location\n            this.props.fetchForecasts(userLocation);\n        }, error => {\n            // user location error\n            // this.props.updateUserLocation(undefined)\n        });\n    }\n\n    private handleTextChange(value: string): void {\n        this.setState({\n            ...this.state,\n            searchText: value,\n        })\n    }\n\n    private handleSearch(value: string): void {\n        if (!value) return;\n        this.props.searchLocations(value);\n    }\n\n    private handleSelect(value: string): void {\n        const results = this.props.locationResults;\n        for (let i = 0; i < results.length; i++) {\n            if (results[i].name === value) {\n                this.props.selectLocation(results[i])\n                this.props.fetchForecasts(results[i])\n                break;\n            }\n        }\n    }\n\n    public render() {\n        let options: JSX.Element[] = [];\n\n        // Loading\n        if (this.props.isLoading)\n            options.push(CreateOption(<Spin />, \"spin\", 0));\n        else {\n            // Response error\n            if (this.props.errorMessage) {\n                options.push(CreateOption(\n                    <Text type=\"danger\">Error! Response status: {this.props.errorMessage}</Text>,\n                    \"error\", 0\n                ));\n            }\n            else {\n\n                // No locations found\n                if (this.props.locationResults.length === 0)\n                    options.push(CreateOption(<Text>No locations found.</Text>, \"no locations\", 0));\n                // Locations found\n                else {\n                    const locations = this.props.locationResults;\n\n                    for (let i = 0; i < locations.length; i++) {\n                        const location = locations[i]\n\n                        options.push(CreateOption(\n                            <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"space-between\" }}>\n                                <Text strong>{location.name}  </Text>\n                                {<Text type=\"secondary\">{location.country}</Text>}\n                            </div>,\n                            location.name,\n                            i\n                        ))\n                    }\n                }\n            }\n        }\n\n        return (\n            <Select\n                showSearch\n                style={this.props.style}\n                value={this.state.searchText ? this.state.searchText : undefined} // the placeholder only shows when value=undefined\n                placeholder=\"Sök\"\n                size=\"large\"\n                defaultActiveFirstOption={false}\n                showArrow={false}\n                filterOption={false}\n                onSearch={value => this.handleSearch(value)}\n                onChange={value => this.handleTextChange(value)}\n                onSelect={value => this.handleSelect(value)}\n                notFoundContent={null}\n            >\n                {options}\n            </Select>\n        );\n    }\n}\n\nfunction CreateOption(content: JSX.Element, value: string, key: any): JSX.Element {\n    return (\n        <Option value={value} key={key}>\n            {content}\n        </Option>\n    );\n}\n\nfunction mapStateToProps(state: AppState) {\n    return {\n        selectedLocation: state.locationSearch.selectedLocation,\n        locationResults: state.locationSearch.searchResults,\n        isLoading: state.locationSearch.isLoading,\n        errorMessage: state.locationSearch.errorMessage\n    }\n}\n\nfunction mapDispatchToProps(dispatch: any) { // TODO: Fix any type\n    return {\n        selectLocation: (location: ILocation) => dispatch(selectLocation(location)),\n        searchLocations: (searchTerm: string) => dispatch(search(searchTerm)),\n        fetchForecasts: (location: ILocation) => dispatch(fetchForecasts(location)),\n        updateUserLocation: (location?: ILocation) => dispatch(updateUserLocation(location))\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(SearchBox);","import React from \"react\";\nimport WeatherView from \"../weather/WeatherTemplate\";\nimport { connect } from \"react-redux\";\nimport { AppState } from \"../../store\";\nimport { ILocation } from \"../../store/types\";\nimport { setDisplayTimes } from \"../../store/forecasts/actions\";\nimport { listHoursFromNow, listDaysFromNow } from \"../../helpers/date\";\nimport { IWeatherStateForecast } from \"../../store/forecasts/types\";\nimport WeatherTableList from \"../weather/WeatherTableList\";\nimport SearchBox from \"../atoms/SearchBox\";\n\ninterface IWeatherPageProps {\n    location?: ILocation,\n    displayTimes: Date[],\n    weatherStateForecasts: IWeatherStateForecast[],\n    setDisplayTimes: (times: Date[]) => void,\n}\n\ninterface IWeatherPageState {\n}\n\nclass WeatherPage extends React.Component<IWeatherPageProps, IWeatherPageState>{\n    render() {\n        console.log(\"Render!!\")\n        return (\n            <div>\n                <SearchBox style={{width: \"100%\"}}/>\n                <WeatherTableList weatherStateForecasts={this.props.weatherStateForecasts} />\n            </div>\n        );\n    }\n}\n\nfunction mapStateToProps(state: AppState) {\n    return {\n        location: state.locationSearch.selectedLocation,\n        displayTimes: state.forecasts.displayTimes,\n        weatherStateForecasts: state.forecasts.weatherStateForecasts,\n    }\n}\n\nfunction mapDispatchToProps(dispatch: any) { // TODO: Fix any type\n    return {\n        setDisplayTimes: (time: Date[]) => dispatch(setDisplayTimes(time)),\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(WeatherPage);","import React, { Dispatch } from 'react';\nimport './App.css';\nimport SearchBox from './components/atoms/SearchBox';\nimport WeatherPage from './components/pages/WeatherPage';\nimport Header from './components/organisms/Header';\n\nfunction App() {\n  return (\n    <div id=\"app\">\n      <div className=\"page\">\n        <WeatherPage />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { ILocationSearchState, LocationSearchActionTypes, SEARCH_START, SEARCH_SUCCESS, SEARCH_FAILURE, SELECT_LOCATION, UPDATE_USER_LOCATION } from './types';\n\nconst initialState: ILocationSearchState = {\n    selectedLocation: undefined,\n    searchResults: [],\n    isLoading: false,\n    errorMessage: '',\n    userLocation: undefined\n}\n\nexport function locationSearchReducer(state = initialState, action: LocationSearchActionTypes): ILocationSearchState {\n    switch (action.type) {\n        case UPDATE_USER_LOCATION:\n            return {\n                ...state,\n                userLocation: action.location\n            };\n        case SELECT_LOCATION:\n            return {\n                ...state,\n                selectedLocation: action.selectedLocation\n            };\n        case SEARCH_START:\n            return {\n                ...state,\n                isLoading: true\n            };\n        case SEARCH_SUCCESS:\n            return {\n                ...state,\n                isLoading: false,\n                searchResults: action.results,\n                errorMessage: \"\",\n            }\n        case SEARCH_FAILURE:\n            return {\n                ...state,\n                isLoading: false,\n                searchResults: [],\n                errorMessage: action.errorMessage\n            };\n        default:\n            return state;\n    }\n}","import { IWeatherState as IForecastState, ForecastActionTypes, FORECAST_FETCH_START, FORECAST_FETCH_SUCCESS, FORECAST_FETCH_FAILURE, SET_DISPLAY_TIMES, IWeatherStateForecast } from \"./types\";\nimport { listHoursFromNow } from \"../../helpers/date\";\nimport { getWeatherProviders } from \"../../weather\";\n\nconst initialState: IForecastState = {\n    weatherStateForecasts: createInitialForecasts(),\n    displayTimes: listHoursFromNow(24),\n    nothing: 1,\n}\n\nexport function forecastReducer(state = initialState, action: ForecastActionTypes): IForecastState {\n    switch (action.type) {\n        case FORECAST_FETCH_START:\n            console.log(\"Fetch start!!\")\n\n            var newWeatherStateForecasts: IWeatherStateForecast[] = JSON.parse(JSON.stringify(state.weatherStateForecasts));\n\n            var weatherStateForecast = newWeatherStateForecasts.find(element => element.weatherProvider.name === action.provider.name);\n            if (weatherStateForecast !== undefined) {\n                weatherStateForecast.loading = true;\n            }\n\n            return {\n                ...state,\n                weatherStateForecasts: newWeatherStateForecasts,\n            };\n\n        case FORECAST_FETCH_SUCCESS:\n            console.log(\"Fetch success!!\");\n\n            var newWeatherStateForecasts: IWeatherStateForecast[] = JSON.parse(JSON.stringify(state.weatherStateForecasts));\n\n            var weatherStateForecast = newWeatherStateForecasts.find(element => element.weatherProvider.name === action.provider.name);\n            if (weatherStateForecast !== undefined) {\n                weatherStateForecast.loading = false;\n                weatherStateForecast.forecast = action.forecast;\n            }\n\n            return {\n                ...state,\n                weatherStateForecasts: newWeatherStateForecasts,\n            };\n\n        case FORECAST_FETCH_FAILURE:\n            console.log(\"Fetch fail\", state)\n\n            // TODO: Implement\n\n            return { ...state }\n\n        case SET_DISPLAY_TIMES:\n            // TODO: remove?\n            return state;\n\n        default:\n            return state;\n    }\n}\n\nfunction createInitialForecasts(): IWeatherStateForecast[] {\n    let forecasts: IWeatherStateForecast[] = []\n    const providers = getWeatherProviders();\n\n    providers.forEach(provider => {\n        let forecast: IWeatherStateForecast = {\n            weatherProvider: provider,\n            loading: true,\n            forecast: {\n                weatherPoints: []\n            }\n        }\n        forecasts.push(forecast)\n    });\n\n    console.log(\"Initial forecasts:\", forecasts)\n\n    return forecasts;\n}\n","import { createStore, compose, combineReducers, applyMiddleware } from \"redux\";\nimport { locationSearchReducer } from \"./locationSearch/reducers\";\nimport thunk from 'redux-thunk';\nimport { forecastReducer } from \"./forecasts/reducers\";\n\nconst rootReducer = combineReducers({\n    locationSearch: locationSearchReducer,\n    forecasts: forecastReducer\n});\n\ndeclare global {\n    interface Window {\n        __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n    }\n}\n\nconst initialState = {}\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nexport default createStore(\n    rootReducer,\n    initialState,\n    compose(\n        applyMiddleware(thunk),\n        composeEnhancers()\n    )\n);\n\nexport type AppState = ReturnType<typeof rootReducer>\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport store from \"./store\";\nimport { Provider } from 'react-redux';\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}