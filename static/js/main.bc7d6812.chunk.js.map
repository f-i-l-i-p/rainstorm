{"version":3,"sources":["icons/weather symbols/day_clear_sky.svg","icons/test.png","weather/types.ts","store/forecasts/types.ts","icons/provider logos/SMHI.jpg","weather/weatherProviders/abstractProvider.ts","weather/weatherProviders/MET.ts","weather/index.ts","weather/weatherProviders/SMHI.ts","store/forecasts/actions.ts","components/atoms/Paper/index.tsx","components/weather/WeatherCell/index.tsx","components/weather/TimeCell/index.tsx","components/weather/WeatherTable/index.tsx","helpers/date.ts","components/weather/WeatherTableList/index.tsx","store/locationSearch/types.ts","store/locationSearch/actions.ts","components/atoms/SearchBox/index.tsx","components/pages/WeatherPage.tsx","App.tsx","serviceWorker.ts","store/locationSearch/reducers.ts","store/forecasts/reducers.ts","store/index.ts","index.tsx"],"names":["WeatherIcon","FORECAST_FETCH_START","FORECAST_FETCH_SUCCESS","FORECAST_FETCH_FAILURE","SET_DISPLAY_TIMES","AbstractProvider","name","logo","this","location","onSuccess","onFailure","requestData","lat","toString","long","response","formatResponse","result","console","error","MET","icons","light_rain","moderate_rain","clear_sky","half_clear_sky","cloudy_sky","fetch","ok","Error","status","forecast","weatherPoints","json","timeSeries","properties","timeseries","currentDateTime","Date","getTime","i","length","timeobj","date","time","symbol_str","data","next_1_hours","summary","symbol_code","next_6_hours","next_12_hours","unknown","warn","weather","temperature","instant","details","air_temperature","wind","wind_speed","gust","NaN","symbol","push","weatherProviders","nearly_clear_sky","overcast","substr","forEach","parameters","parameter","value","getWeatherProviders","searchStart","provider","type","searchSuccess","searchFailure","errorMessage","Paper","props","className","style","children","Text","Typography","log","require","WeatherCell","undefined","Fragment","strong","Math","round","src","default","TimeCell","getHours","slice","WeatherTable","width","height","tableData","providers","map","ignored","index","margin","overflowX","justifyContent","justifyRight","columns","column","weatherMap","get","React","Component","listDates","start","interval","count","times","getDayOffset","today","setHours","setMinutes","setSeconds","setMilliseconds","diff","floor","WeatherTableList","stateForecasts","weatherStateForecasts","stateForecast","weatherProvider","loading","j","weatherPoint","weatherPointDate","dayOffset","Map","k","columnTime","set","splice","getDay","getTableData","getTableName","UPDATE_USER_LOCATION","SELECT_LOCATION","SEARCH_START","SEARCH_SUCCESS","SEARCH_FAILURE","nextSearchTime","now","lastSearch","results","tryPerformSearch","searchTerm","dispatch","performSearch","a","process","locations","toILocations","statusText","loc","country","Number","alt","message","Option","Select","SearchBox","state","searchText","handleTextChange","bind","navigator","geolocation","getCurrentPosition","pos","userLocation","coords","latitude","longitude","altitude","updateUserLocation","selectLocation","fetchForecasts","setState","searchLocations","locationResults","options","isLoading","CreateOption","display","flexDirection","showSearch","placeholder","size","defaultActiveFirstOption","showArrow","filterOption","onSearch","handleSearch","onChange","onSelect","handleSelect","notFoundContent","content","key","connect","selectedLocation","locationSearch","searchResults","trimmed","trim","setTimeout","minSearchDelay","search","fetchForecast","WeatherPage","displayTimes","forecasts","setDisplayTimes","App","id","Boolean","window","hostname","match","initialState","createInitialForecasts","listHoursFromNow","nothing","rootReducer","combineReducers","action","weatherStateForecast","newWeatherStateForecasts","JSON","parse","stringify","find","element","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","applyMiddleware","thunk","ReactDOM","render","store","document","getElementById","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.bc7d6812.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/day_clear_sky.3cec5a70.svg\";","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAA7JJREFUWIXVl09oFHcUxz8zCQY8VNl76GE9yOJtdBFvqxdBGA9tKAQ0l7LtSVywSMlCoeRQiuIp5CJCNZ5asPXUloQuKdiGJNuSTXa2KLooojHLZrdZ4v77/X49bCb+HGdmd7Ol0C8Ms3/ee9/3vr/fvN8b+D9j6hJT0kFOXWJqvzGMQRKQBaQBhgJlHsXcT4y3nJJjJEUeIR3k7NfMdnNWCqXfB0ZrjZYqoFQBJQvIRz/y6PgxjgfZSwepCijpIINsoqNEM9+QKS9SbqzSKM5TtGJYvsa6Am4iIo+o/UHNTmB77SeTTAoHMZlk0i/e+DnGRR7hxnKv1fushipx5iRnNh+w2c7T1hXxSyIMjTUarn9rnVYjR+PpLzwNVMAvkfb6mySqy1T1/1MXSYk8YmuRrUSchNf/dZbXroo9k3phxbCK8xRr2c4yWDGs8iJl6SD1pZJ5ZOkBJT0RO4FdWabSr3K+iI4Szd0np5P6XbKArGWp+Snih576gJ3AvjfNPdN891lXdB5BwxNLSmT8Q+IreVYGTqCepT5ykBGX0Eum/6Z/3vqbrUicSFjsnrrXgYMcCCLfrcLwU+LwexxOjpEMi92TAsJBmEZ4st7k3O9SIodiDAX5dVUgNUFKJ3crde8uvMq43w0zvEgzcojIzBfMbK+w/SzDs41f2Wiv005dJAVw7SrX/Bz9liIIyTGS02mmpYN0O+31z7gOYFye4PKNz7nhdXKl00+8fkh1CIEwhzC9S2QexTRvf8/tW99xa2eHnReveFEqUxISceUrruyHzLs0AC83eTkzy4xSKPfkzPxOBnqoSDpIw+hdgXc2o0Kd+IATbj+IHCJy4TwX7vzAnXKVcteArTVaw8MMh5HoZLubYy/hZpvmyLFOD/FD16dg4ioT3p3v14h0ct1m4xUbYfF72lQPf+Lhkfc5skfoIQtCs0Xz1EecCmvHPXXCsx9zNvcXuT0FDIy91ru7sZRC6RtQSmQ38r4RHSW69C1LjVUaYaeidN4MLwMdyelPSQeNXFYMqzhHsZ6lXv+zc0kH2V6nPX6OcdeulqXW91DijmR6RX1nv4sn8zxx4zz+mcehxnYCe3uFbe8smP6EtJ99Ik7i+QLPw4YPK4bVynembekgb37JzcAEqstU9Wm49Bul0yc5HWRfWaKiCqjKEpWwwhbusqAXFGhoJ7BrWWrFOYph7wMuhNMZuYWDCLOLjhItzlH0U2CgVzORR5gmZrczPwz7ep9z0WzR1O//Of6NsfsfClNnd3sT9V8AAAAASUVORK5CYII=\"","import { ILocation } from \"../store/types\";\n\nexport interface IForecast {\n    weatherPoints: IWeatherTime[],\n}\n\nexport interface IWeatherTime {\n    time: Date,\n    weather: IWeather,\n}\n\nexport interface IWeather {\n    temperature: number,\n    wind: number,\n    gust: number,\n    symbol: WeatherIcon,\n}\n\nexport interface IWeatherProvider {\n    name: string;\n    logo: string;\n    fetchForecast(location: ILocation, onSuccess: (result: IForecast) => any, onFailure: (error: Error) => any): void;\n}\n\nexport enum WeatherIcon {\n    unknown = \"unknown\",\n    // Cloudiness\n    clear_sky = \"clear_sky\",\n    nearly_clear_sky = \"nearly_clear_sky\",\n    half_clear_sky = \"half_clear_sky\",\n    cloudy_sky = \"cloudy_sky\",\n    overcast = \"overcast\",\n    // Rain\n    light_rain = \"light_rain\",\n    moderate_rain = \"moderate_rain\",\n    heavy_rain = \"heavy_rain\",\n}","import { IForecast, IWeatherProvider } from \"../../weather/types\";\n\nexport interface IWeatherStateForecast {\n    weatherProvider: IWeatherProvider;\n    loading: boolean;\n    forecast: IForecast;\n}\n\nexport interface IWeatherState {\n    weatherStateForecasts: IWeatherStateForecast[],\n    displayTimes: Date[],\n    nothing: number,\n}\n\nexport const FORECAST_FETCH_START = 'FORECAST_FETCH_START';\n\ninterface IFetchStartAction {\n    type: typeof FORECAST_FETCH_START,\n    provider: IWeatherProvider\n}\n\nexport const FORECAST_FETCH_SUCCESS = 'FORECAST_FETCH_SUCCESS';\n\ninterface IFetchSuccessAction {\n    type: typeof FORECAST_FETCH_SUCCESS,\n    forecast: IForecast,\n    provider: IWeatherProvider\n}\n\nexport const FORECAST_FETCH_FAILURE = 'FORECAST_FETCH_FAILURE';\n\ninterface IFetchFailureAction {\n    type: typeof FORECAST_FETCH_FAILURE,\n    errorMessage: string,\n    provider: IWeatherProvider\n}\n\nexport const SET_DISPLAY_TIMES = 'SET_DISPLAY_TIMES';\n\ninterface ISetDisplayTimesAction {\n    type: typeof SET_DISPLAY_TIMES,\n    displayTimes: Date[]\n}\n\nexport type ForecastActionTypes = IFetchStartAction | IFetchSuccessAction | IFetchFailureAction | ISetDisplayTimesAction;","export default __webpack_public_path__ + \"static/media/SMHI.147242e8.jpg\";","import { ILocation } from \"../../store/types\";\nimport { IForecast, IWeatherProvider } from \"../types\";\n\nexport default abstract class AbstractProvider implements IWeatherProvider {\n    name: string;\n    logo: string;\n\n    constructor(name: string, logo: string) {\n        this.name = name;\n        this.logo = logo;\n    }\n\n    public async fetchForecast(location: ILocation, onSuccess: (result: IForecast) => any, onFailure: (error: Error) => any) {\n        let result: IForecast;\n\n        try {\n            // Send a request\n            let response = await this.requestData(location.lat.toString(), location.long.toString());\n\n            // Format the response \n            result = await this.formatResponse(response);\n\n        } catch (e) {\n            console.error(e)\n            onFailure(e);\n            return;\n        }\n\n        onSuccess(result)\n    }\n\n    protected abstract requestData(lat: string, long: string): Promise<Response>;\n    protected abstract formatResponse(response: Response): Promise<IForecast>;\n}","import logo from '../../icons/provider logos/SMHI.jpg'\nimport { IForecast, IWeather, IWeatherTime, WeatherIcon } from \"../types\";\nimport AbstractProvider from \"./abstractProvider\";\n\n\nexport default class MET extends AbstractProvider {\n    constructor() {\n        super(\"Yr\", logo)\n    }\n\n    private icons: any = {\n        \"lightrain\": WeatherIcon.light_rain,\n        \"rain\": WeatherIcon.moderate_rain,\n        \"clearsky_night\": WeatherIcon.clear_sky,\n        \"partlycloudy_day\": WeatherIcon.half_clear_sky,\n        \"partlycloudy_night\": WeatherIcon.half_clear_sky,\n        \"cloudy\": WeatherIcon.cloudy_sky,\n    }\n\n    protected async requestData(lat: string, long: string): Promise<Response> {\n        const result = await fetch('https://api.met.no/weatherapi/locationforecast/2.0/compact?lat='\n            + lat + '&lon=' + long);\n\n        if (!result.ok) {\n            throw new Error(\"Weather response error! status: \" + result.status)\n        }\n\n        return result;\n    }\n\n    protected async formatResponse(response: Response): Promise<IForecast> {\n        let forecast: IForecast = {\n            weatherPoints: [],\n        }\n\n        const json = await response.json();\n\n        const timeSeries: [] = json.properties.timeseries;\n\n        const currentDateTime = new Date().getTime();\n\n        // Loop through all timeseries\n        for (let i = 0; i < timeSeries.length; i++) {\n            const timeobj: any = timeSeries[i];\n            const date: Date = new Date(timeobj.time);\n\n            // If this is old weather.\n            if (date.getTime() < currentDateTime) {\n                continue;\n            }\n\n            let symbol_str: string;\n            if (timeobj.data.next_1_hours) {\n                symbol_str = timeobj.data.next_1_hours.summary.symbol_code;\n            }\n            else if (timeobj.data.next_6_hours) {\n                symbol_str = timeobj.data.next_6_hours.summary.symbol_code;\n            }\n            else if (timeobj.data.next_12_hours) {\n                symbol_str = timeobj.data.next_12_hours.summary.symbol_code;\n            }\n            else {\n                continue;\n            }\n\n            const symbol = this.icons[symbol_str] || WeatherIcon.unknown;\n            if (symbol === WeatherIcon.unknown) {\n                console.warn(\"Unknown symbol\", symbol_str)\n            }\n\n            const weather: IWeather = {\n                temperature: timeobj.data.instant.details.air_temperature,\n                wind: timeobj.data.instant.details.wind_speed,\n                gust: NaN,\n                symbol: this.icons[symbol_str] || WeatherIcon.unknown,\n            }\n\n            forecast.weatherPoints.push({ time: date, weather: weather })\n        }\n\n        return forecast;\n    }\n}","import { METHODS } from \"http\";\nimport { ILocation } from \"../store/types\";\nimport { IForecast, IWeatherProvider } from \"./types\";\nimport MET from \"./weatherProviders/MET\";\nimport SMHI from \"./weatherProviders/SMHI\";\n\nconst weatherProviders: IWeatherProvider[] = [new SMHI(), new MET()]\n\n\nexport function getWeatherProviders(): IWeatherProvider[] {\n    return weatherProviders;\n}\n","import logo from '../../icons/provider logos/SMHI.jpg'\nimport { IForecast, IWeather, WeatherIcon } from \"../types\";\nimport AbstractProvider from \"./abstractProvider\";\n\n\nexport default class SMHI extends AbstractProvider {\n    constructor() {\n        super(\"SMHI\", logo)\n    }\n\n    private icons = {\n        1: WeatherIcon.clear_sky,          // Clear sky\n        2: WeatherIcon.nearly_clear_sky,   // Nearly clear sky\n        3: WeatherIcon.half_clear_sky,     // Variable cloudiness\n        4: WeatherIcon.half_clear_sky,     // Half clear sky\n        5: WeatherIcon.cloudy_sky,         // Cloudy sky\n        6: WeatherIcon.overcast,           // Overcast\n        18: WeatherIcon.light_rain,        // Light rain\n        19: WeatherIcon.moderate_rain,     // Moderate rain\n    }\n\n    protected async requestData(lat: string, long: string): Promise<Response> {\n        const max = 9; // the maximum precision allowed by the api (including decimal point)\n        const result = await fetch('https://opendata-download-metfcst.smhi.se/api/category/pmp3g/version/2/geotype/point/lon/'\n            + long.substr(0, max) + '/lat/' + lat.substr(0, max) + '/data.json');\n\n        if (!result.ok) {\n            throw new Error(\"Weather response error! status: ' + result.status\")\n        }\n\n        return result;\n    }\n\n    protected async formatResponse(response: Response): Promise<IForecast> {\n        let forecast: IForecast = {\n            weatherPoints: [],\n        }\n\n        const json = await response.json();\n\n        const timeSeries: [] = json['timeSeries'];\n\n        const currentDateTime = new Date().getTime();\n\n        timeSeries.forEach((time: any) => {\n            // Get the time:\n            const date = new Date(time['validTime']);\n\n            if (date.getTime() >= currentDateTime) {\n                // Get the weather for this time:\n\n                // Weather parameter descriptions can be found at:\n                // https://opendata.smhi.se/apidocs/metfcst/parameters.html#parameter-table\n\n                const parameters: [] = time['parameters']\n\n                const weather: IWeather = {\n                    temperature: NaN,\n                    wind: NaN,\n                    gust: NaN,\n                    symbol: WeatherIcon.unknown,\n                }\n\n                // TODO: Optimize. Don't loop through all parameters.\n                parameters.forEach(parameter => {\n                    const value = parameter['values'][0];\n                    switch (parameter['name']) {\n                        case 't':\n                            weather.temperature = value;\n                            break;\n                        case 'ws':\n                            weather.wind = value;\n                            break;\n                        case 'gust':\n                            weather.gust = value;\n                            break;\n                        case 'Wsymb2':\n                            let icon = this.icons[value];\n                            if (!icon) {\n                                console.warn(\"Unknown symbol value\", value)\n                                weather.symbol = WeatherIcon.unknown;\n                                break;\n                            }\n                            weather.symbol = this.icons[value];\n                            break;\n                    }\n                });\n\n                forecast.weatherPoints.push({ time: date, weather: weather });\n            }\n        });\n\n        return forecast;\n    }\n}","import { ForecastActionTypes, FORECAST_FETCH_START, FORECAST_FETCH_SUCCESS, FORECAST_FETCH_FAILURE, SET_DISPLAY_TIMES } from \"./types\";\nimport { ILocation } from \"../types\";\nimport { Dispatch } from \"redux\";\nimport { getWeatherProviders } from \"../../weather\";\nimport { IForecast, IWeatherProvider } from \"../../weather/types\";\n\nfunction searchStart(provider: IWeatherProvider): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_START,\n        provider: provider\n    }\n}\n\nfunction searchSuccess(provider: IWeatherProvider, forecast: IForecast): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_SUCCESS,\n        forecast: forecast,\n        provider: provider\n    }\n}\n\nfunction searchFailure(provider: IWeatherProvider, errorMessage: string): ForecastActionTypes {\n    return {\n        type: FORECAST_FETCH_FAILURE,\n        errorMessage: errorMessage,\n        provider: provider\n    }\n}\n\nexport const fetchForecasts = (location: ILocation) => async (dispatch: Dispatch) => {\n    const onSuccess = (provider: IWeatherProvider, result: IForecast) => dispatch(searchSuccess(provider, result));\n    const onFailure = (provider: IWeatherProvider, error: Error) => dispatch(searchFailure(provider, error.message));\n\n    const providers = getWeatherProviders();\n\n    providers.forEach(provider => {\n        dispatch(searchStart(provider));\n        provider.fetchForecast(location, (result: IForecast) => onSuccess(provider, result), (error: Error) => onFailure(provider, error));\n    });\n\n}\n\nexport function setDisplayTimes(displayTimes: Date[]) {\n    return {\n        type: SET_DISPLAY_TIMES,\n        displayTimes: displayTimes\n    };\n}\n","import React from \"react\";\nimport CSS from 'csstype'\n\nimport './style.css';\n\ninterface Props {\n    style?: CSS.Properties,\n    children?: React.ReactNode\n}\n\nconst Paper = (props: Props) => (\n    <div className=\"paper\" style={props.style}>\n        {props.children}\n    </div>\n);\n\nexport default Paper;","import React from \"react\";\nimport { Typography } from \"antd\";\n\nimport './style.css';\nimport { IWeather } from \"../../../weather/types\";\n\nconst { Text } = Typography;\n\ninterface Props {\n    weather: IWeather\n}\n\nconsole.log(require(\"../../../icons/weather symbols/day_\" + \"clear_sky\" + \".svg\"))\n\nconst WeatherCell = (props: Props) => (\n    <div className=\"weather_cell\">\n        {props.weather != undefined &&\n            <React.Fragment>\n                <Text strong>{Math.round(props.weather.temperature)} °C</Text>\n                {props.weather.symbol &&\n                    <img className='weather_symbol' src={require(\"../../../icons/test.png\").default} />\n                }\n                <div>\n                    <Text strong>{Math.round(props.weather.wind)}</Text>\n                    <Text type=\"secondary\"> ({Math.round(props.weather.gust)}) </Text>\n                    <Text strong>m/s</Text>\n                </div>\n            </React.Fragment>\n        }\n    </div>\n);\n\n\nexport default WeatherCell;","import React from \"react\";\nimport { Typography } from \"antd\";\n\nimport './style.css';\n\nconst { Text } = Typography;\n\ninterface Props {\n    time: Date\n}\n\nconst TimeCell = (props: Props) => (\n    <div className=\"time_cell\">\n        <Text strong>{('0' + props.time.getHours()).slice(-2)}</Text>\n    </div>\n);\n\nexport default TimeCell;","import React from \"react\";\nimport Paper from \"../../atoms/Paper\";\nimport WeatherCell from \"../WeatherCell\";\nimport { Divider, Typography } from \"antd\";\nimport TimeCell from \"../TimeCell\";\nimport { IForecast, IWeather } from \"../../../weather/types\";\nimport './style.css';\nimport { ITableData } from \"./types\";\n\ninterface IWeatherTableListProps {\n    tableData: ITableData,\n    name: string,\n    justifyRight: boolean,\n}\n\nclass WeatherTable extends React.Component<IWeatherTableListProps> {\n    public render() {\n        return (\n            <div>\n                {this.props.name}\n                <div className=\"columns\">\n\n                    {/* Time row background */}\n                    <div className=\"right-column\">\n                        <div className=\"time-row\" style={{ width: '100%' }}>\n                            <Paper style={{ width: '100%', height: '100%' }} />\n                        </div>\n                    </div>\n\n                    {/* Weather row background. One for each provider. */}\n                    <div className=\"all-columns\">\n                        <div className=\"time-row\" />\n                        {this.props.tableData.providers.map((ignored, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Paper style={{ width: '100%', height: '100%' }} />\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Provider Name */}\n                    <div className=\"left-column\">\n                        <div className=\"time-row\" />\n                        {this.props.tableData.providers.map((provider, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Typography className=\"weather-provider-name\">\n                                    {provider.name}\n                                </Typography>\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Divider */}\n                    <div className=\"divider-column\">\n                        <div className=\"time-row\" />\n                        {this.props.tableData.providers.map((ignored, index) =>\n                            <div key={index} className=\"weather-row\">\n                                <Divider type=\"vertical\" style={{ height: 'calc(100% - 5px)', margin: 0 }} />\n                            </div>\n                        )}\n                    </div>\n\n                    {/* Time cells and Weather cells */}\n                    <div className=\"right-column\" style={{ overflowX: 'auto' }}>\n                        <div className=\"time-row\" style={{justifyContent: this.props.justifyRight ? \"flex-end\" : \"space-around\"}}>\n                            {this.props.tableData.columns.map((column, index) =>\n                                <TimeCell key={index} time={column.date} />\n                            )}\n                        </div>\n                        {this.props.tableData.providers.map((provider, index) =>\n                            <div key={index} className=\"weather-row\" style={{justifyContent: this.props.justifyRight ? \"flex-end\" : \"space-around\"}}>\n                                {this.props.tableData.columns.map((column, index) =>\n                                    <WeatherCell key={index} weather={column.weatherMap.get(provider) as IWeather} />\n                                )}\n                            </div>\n                        )}\n                    </div>\n                </div >\n            </div>\n        );\n    }\n}\n\nexport default WeatherTable;","/**\n * Returns a list of Date objects with one hour difference, starting with the current hour.\n * @param count The number of Date objects to return.\n */\nexport function listHoursFromNow(count: number): Date[] {\n    let start = new Date();\n    start.setHours(start.getHours() + 1);\n    start.setMinutes(0);\n    start.setSeconds(0);\n    start.setMilliseconds(0);\n    return listDates(start, 3600000, count);\n}\n\n/**\n * Returns a list of Date objects with one day difference, the first day will\n * be at the current hour and following days will be at the 12th hour.\n * @param count The number of Date objects to return.\n */\nexport function listDaysFromNow(count: number): Date[] {\n    let first = new Date();\n    first.setHours(first.getHours() + 1);\n    first.setMinutes(0);\n    first.setSeconds(0);\n    first.setMilliseconds(0);\n\n    let start = new Date(first.getTime());\n    start.setHours(12);\n    start.setDate(start.getDate() + 1);\n\n    return [start, ...listDates(start, 86400000, count - 1)];\n}\n\n/**\n * Returns an array of Date objects.\n * @param start The first date in the array.\n * @param interval The time difference in milliseconds.\n * @param count The number of Date objects to return.\n */\nexport function listDates(start: Date, interval: number, count: number): Date[] {\n    let times: Date[] = []\n\n    for (let i = 0; i < count; i++) {\n        times.push(new Date(start.getTime() + (i * interval)));\n    }\n\n    return times;\n}\n\n/**\n * Returns the number of days from today to the given date.\n */\nexport function getDayOffset(date: Date) {\n    let today = new Date();\n    today.setHours(0);\n    today.setMinutes(0);\n    today.setSeconds(0);\n    today.setMilliseconds(0);\n\n    let diff = date.getTime() - today.getTime();\n\n    return Math.floor(diff / 86400000);  // 86400000 milliseconds in a day)\n}","import React from \"react\";\nimport './style.css';\nimport { IWeatherStateForecast } from \"../../../store/forecasts/types\";\nimport WeatherTable from \"../WeatherTable\";\nimport { getDayOffset, listHoursFromNow } from \"../../../helpers/date\";\nimport { ITableData } from \"../WeatherTable/types\";\nimport { table } from \"console\";\nimport { IWeather } from \"../../../weather/types\";\nimport { resolveSoa } from \"dns/promises\";\n\ninterface IWeatherTableListProps {\n    weatherStateForecasts: IWeatherStateForecast[],\n}\n\nexport default class WeatherTableList extends React.Component<IWeatherTableListProps> {\n\n    /**\n     * Converts the data from props to data accepted by the weather tables.\n     * @returns Array with table data.\n     */\n    private getTableData(): ITableData[] {\n        const result: ITableData[] = [];\n\n        const stateForecasts = this.props.weatherStateForecasts;\n        const providers = stateForecasts.map(stateForecast => { return stateForecast.weatherProvider });\n\n        // For every provider\n        for (let i = 0; i < stateForecasts.length; i++) {\n            const stateForecast = stateForecasts[i];\n\n            if (stateForecast.loading) {\n                continue;\n            }\n\n            // For every weather point\n            for (let j = 0; j < stateForecast.forecast.weatherPoints.length; j++) {\n                const weatherPoint = stateForecast.forecast.weatherPoints[j];\n\n                // Sometimes the date is a string because the reducer is bad.\n                let weatherPointDate: Date;\n                if (typeof weatherPoint.time === 'string')\n                    weatherPointDate = new Date(weatherPoint.time);\n                else\n                    weatherPointDate = weatherPoint.time\n\n                const dayOffset = getDayOffset(weatherPointDate);\n\n                if (dayOffset < 0) {\n                    console.warn(\"Old weather data\");\n                    continue;\n                }\n\n                // Create new table if needed\n                if (dayOffset >= result.length) {\n                    result.push({\n                        columns: [],\n                        providers: providers,\n                    })\n                }\n\n                const tableData = result[dayOffset];\n                const time = weatherPointDate.getTime();\n\n                // If no columns, add one\n                if (tableData.columns.length === 0) {\n                    tableData.columns.push({\n                        date: weatherPointDate,\n                        weatherMap: new Map(),\n                    })\n                }\n\n                // Create new column if needed, and add data.\n                for (let k = tableData.columns.length - 1; k >= 0; k--) {\n                    const column = tableData.columns[k];\n                    const columnTime = column.date.getTime();\n\n                    // Column already exists\n                    if (columnTime === time) {\n                        // Add data\n                        column.weatherMap.set(stateForecast.weatherProvider, weatherPoint.weather);\n                        break;\n                    }\n                    // Column should be after this column\n                    else if (columnTime < time) {\n                        // Add column\n                        tableData.columns.splice(k + 1, 0, {\n                            date: weatherPointDate,\n                            weatherMap: new Map(),\n                        })\n\n                        // Make sure that the data gets added in the next loop.\n                        k += 2;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private getTableName(index: number, date: Date | undefined): string {\n        let result = \"\";\n\n        if (!date) return result;\n\n        switch (index) {\n            case 0:\n                result += \"Idag, \";\n                break;\n            case 1:\n                result += \"Imorgon, \"\n        }\n\n        switch (date.getDay()) {\n            case 1:\n                result += \"Måndag\";\n                break;\n            case 2:\n                result += \"Tisdag\";\n                break;\n            case 3:\n                result += \"Onsdag\";\n                break;\n            case 4:\n                result += \"Torsdag\";\n                break;\n            case 5:\n                result += \"Fredag\";\n                break;\n            case 6:\n                result += \"Lördag\";\n                break;\n            case 0:\n                result += \"Söndag\";\n                break;\n        }\n\n        return result;\n    }\n\n    public render() {\n        let tableData = this.getTableData();\n\n        return (\n            <div className=\"list\">\n                {tableData.map((data, index) =>\n                    <WeatherTable key={index} tableData={data} justifyRight={index==0}  name={this.getTableName(index, data.columns.length ? data.columns[0].date : undefined)} />\n                )}\n            </div>\n        );\n    }\n}\n","import { ILocation } from \"../types\";\n\nexport interface ILocationSearchState {\n    selectedLocation?: ILocation,\n    searchResults: ILocation[],\n    isLoading: boolean,\n    errorMessage: string,\n    userLocation?: ILocation,\n}\n\nexport const UPDATE_USER_LOCATION = 'UPDATE_USER_LOCATION';\n\ninterface IUpdateUserLocationAction {\n    type: typeof UPDATE_USER_LOCATION,\n    location?: ILocation\n}\n\nexport const SELECT_LOCATION = 'SELECT_LOCATION';\n\ninterface ISelectLocationAction {\n    type: typeof SELECT_LOCATION,\n    selectedLocation: ILocation\n}\n\nexport const SEARCH_START = 'SEARCH_START';\n\ninterface ISearchStartAction {\n    type: typeof SEARCH_START,\n}\n\nexport const SEARCH_SUCCESS = 'SEARCH_SUCCESS';\n\ninterface ISearchSuccessAction {\n    type: typeof SEARCH_SUCCESS,\n    results: ILocation[]\n}\n\nexport const SEARCH_FAILURE = 'SEARCH_FAILURE';\n\ninterface ISearchFailureAction {\n    type: typeof SEARCH_FAILURE,\n    errorMessage: string\n}\n\nexport type LocationSearchActionTypes = IUpdateUserLocationAction | ISelectLocationAction | ISearchStartAction | ISearchSuccessAction | ISearchFailureAction;","import { LocationSearchActionTypes, SEARCH_START, SEARCH_SUCCESS, SEARCH_FAILURE, SELECT_LOCATION, UPDATE_USER_LOCATION } from './types';\nimport { Dispatch } from 'redux';\nimport { ILocation } from '../types';\n\n\nconst minSearchDelay: number = 1000;\nvar nextSearchTime: number = Date.now();\nvar lastSearch: String = \"\"\n\n\nexport function updateUserLocation(location?: ILocation): LocationSearchActionTypes {\n    return {\n        type: UPDATE_USER_LOCATION,\n        location: location\n    }\n}\n\nexport function selectLocation(location: ILocation): LocationSearchActionTypes {\n    return {\n        type: SELECT_LOCATION,\n        selectedLocation: location\n    }\n}\n\nfunction searchStart(): LocationSearchActionTypes {\n    return {\n        type: SEARCH_START,\n    };\n}\n\nfunction searchSuccess(results: ILocation[]): LocationSearchActionTypes {\n    return {\n        type: SEARCH_SUCCESS,\n        results: results\n    }\n}\n\nfunction searchFailure(errorMessage: string): LocationSearchActionTypes {\n    return {\n        type: SEARCH_FAILURE,\n        errorMessage: errorMessage\n    }\n}\n\nexport const search = (searchTerm: string) => async (dispatch: Dispatch) => {\n    const trimmed = searchTerm.trim()\n    if (trimmed === lastSearch) {\n        return;\n    }\n\n    lastSearch = trimmed;\n\n    dispatch(searchStart());\n\n    nextSearchTime = Date.now() + minSearchDelay;\n    setTimeout(() => tryPerformSearch(searchTerm, dispatch), minSearchDelay + 1) // Add 1 for extra marginal\n}\n\n/**\n * Tries to perform a search, but cancels if the search time has moved.\n */\nfunction tryPerformSearch(searchTerm: string, dispatch: Dispatch) {\n    if (Date.now() < nextSearchTime) {\n        return;\n    }\n\n    performSearch(searchTerm, dispatch);\n}\n\nasync function performSearch(searchTerm: string, dispatch: Dispatch) {\n    const key = process.env.REACT_APP_LOCATIONIQ;\n    const address = \"https://api.locationiq.com/v1/autocomplete.php\";\n\n    const result = await fetch(`${address}?key=${key}&q=${searchTerm}&accept-language=sv`);//&accept-language=native');\n\n    const json = await result.json();\n\n    if (result.ok) {\n        const locations = toILocations(json);\n        dispatch(searchSuccess(locations));\n    }\n    // Returns this with a 404 status when no location found.\n    else if ( json['error'] == \"Unable to geocode\" ) {\n        const locations: ILocation[] = [];\n        dispatch(searchSuccess(locations))\n    }\n    else {\n        console.error('Geocode response error! status: ' + result.statusText);\n        dispatch(searchFailure(result.status.toString()));\n    }\n}\n\n// Converts JSON data from locationIQ to an ILocation array\nfunction toILocations(json: any): ILocation[] {\n    const locations: ILocation[] = []\n\n    try {\n        for (const loc of json) {\n            locations.push({\n                country: loc['display_address'],\n                name: loc['display_place'],\n                lat: Number(loc['lat']),\n                long: Number(loc['lon']),\n                alt: 0,\n            });\n        }\n\n        console.log(locations)\n        return locations\n    }\n    catch (error) {\n        console.error(error.message)\n        return []\n    }\n}\n","import React from \"react\";\nimport { Select, Typography, Spin } from 'antd';\nimport { connect } from 'react-redux';\nimport { AppState } from \"../../../store\";\nimport { search, selectLocation, updateUserLocation } from \"../../../store/locationSearch/actions\";\nimport { ILocation } from \"../../../store/types\";\nimport { fetchForecasts } from \"../../../store/forecasts/actions\";\n\nconst { Option } = Select;\nconst { Text } = Typography;\n\ninterface ISearchPageProps {\n    style?: React.CSSProperties,\n    selectedLocation?: ILocation,\n    isLoading: boolean,\n    errorMessage: string\n    locationResults: ILocation[],\n    selectLocation: (location: ILocation) => void,\n    searchLocations: (searchTerm: string) => void,\n    fetchForecasts: (location: ILocation) => void,\n    updateUserLocation: (location?: ILocation) => void,\n}\n\ninterface ISearchPageState {\n    searchText: string,\n}\n\nclass SearchBox extends React.Component<ISearchPageProps, ISearchPageState> {\n    constructor(props: Readonly<ISearchPageProps>) {\n        super(props);\n\n        this.state = {\n            searchText: \"\",\n        }\n\n        this.handleTextChange = this.handleTextChange.bind(this);\n    }\n\n    componentDidMount() {\n        // Get the user location\n        // TODO: Move this somewhere else\n        navigator.geolocation.getCurrentPosition(pos => {\n            const userLocation: ILocation = {\n                country: '',\n                name: 'Your Location',\n                lat: pos.coords.latitude,\n                long: pos.coords.longitude,\n                alt: pos.coords.altitude ? pos.coords.altitude : 0\n            };\n            // update user location\n            this.props.updateUserLocation(userLocation);\n            // select user location\n            this.props.selectLocation(userLocation);\n            // fetch forecast for user location\n            this.props.fetchForecasts(userLocation);\n        }, error => {\n            // user location error\n            // this.props.updateUserLocation(undefined)\n        });\n    }\n\n    private handleTextChange(value: string): void {\n        this.setState({\n            ...this.state,\n            searchText: value,\n        })\n    }\n\n    private handleSearch(value: string): void {\n        if (!value) return;\n        this.props.searchLocations(value);\n    }\n\n    private handleSelect(value: string): void {\n        const results = this.props.locationResults;\n        for (let i = 0; i < results.length; i++) {\n            if (results[i].name === value) {\n                this.props.selectLocation(results[i])\n                this.props.fetchForecasts(results[i])\n                break;\n            }\n        }\n    }\n\n    public render() {\n        let options: JSX.Element[] = [];\n\n        // Loading\n        if (this.props.isLoading)\n            options.push(CreateOption(<Spin />, \"spin\", 0));\n        else {\n            // Response error\n            if (this.props.errorMessage) {\n                options.push(CreateOption(\n                    <Text type=\"danger\">Error! Response status: {this.props.errorMessage}</Text>,\n                    \"error\", 0\n                ));\n            }\n            else {\n\n                // No locations found\n                if (this.props.locationResults.length === 0)\n                    options.push(CreateOption(<Text>No locations found.</Text>, \"no locations\", 0));\n                // Locations found\n                else {\n                    const locations = this.props.locationResults;\n\n                    for (let i = 0; i < locations.length; i++) {\n                        const location = locations[i]\n\n                        options.push(CreateOption(\n                            <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"space-between\" }}>\n                                <Text strong>{location.name}  </Text>\n                                {<Text type=\"secondary\">{location.country}</Text>}\n                            </div>,\n                            location.name,\n                            i\n                        ))\n                    }\n                }\n            }\n        }\n\n        return (\n            <Select\n                showSearch\n                style={this.props.style}\n                value={this.state.searchText ? this.state.searchText : undefined} // the placeholder only shows when value=undefined\n                placeholder=\"Sök\"\n                size=\"large\"\n                defaultActiveFirstOption={false}\n                showArrow={false}\n                filterOption={false}\n                onSearch={value => this.handleSearch(value)}\n                onChange={value => this.handleTextChange(value)}\n                onSelect={value => this.handleSelect(value)}\n                notFoundContent={null}\n            >\n                {options}\n            </Select>\n        );\n    }\n}\n\nfunction CreateOption(content: JSX.Element, value: string, key: any): JSX.Element {\n    return (\n        <Option value={value} key={key}>\n            {content}\n        </Option>\n    );\n}\n\nfunction mapStateToProps(state: AppState) {\n    return {\n        selectedLocation: state.locationSearch.selectedLocation,\n        locationResults: state.locationSearch.searchResults,\n        isLoading: state.locationSearch.isLoading,\n        errorMessage: state.locationSearch.errorMessage\n    }\n}\n\nfunction mapDispatchToProps(dispatch: any) { // TODO: Fix any type\n    return {\n        selectLocation: (location: ILocation) => dispatch(selectLocation(location)),\n        searchLocations: (searchTerm: string) => dispatch(search(searchTerm)),\n        fetchForecasts: (location: ILocation) => dispatch(fetchForecasts(location)),\n        updateUserLocation: (location?: ILocation) => dispatch(updateUserLocation(location))\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(SearchBox);","import React from \"react\";\nimport WeatherView from \"../weather/WeatherTemplate\";\nimport { connect } from \"react-redux\";\nimport { AppState } from \"../../store\";\nimport { ILocation } from \"../../store/types\";\nimport { setDisplayTimes } from \"../../store/forecasts/actions\";\nimport { listHoursFromNow, listDaysFromNow } from \"../../helpers/date\";\nimport { IWeatherStateForecast } from \"../../store/forecasts/types\";\nimport WeatherTableList from \"../weather/WeatherTableList\";\nimport SearchBox from \"../atoms/SearchBox\";\n\ninterface IWeatherPageProps {\n    location?: ILocation,\n    displayTimes: Date[],\n    weatherStateForecasts: IWeatherStateForecast[],\n    setDisplayTimes: (times: Date[]) => void,\n}\n\ninterface IWeatherPageState {\n}\n\nclass WeatherPage extends React.Component<IWeatherPageProps, IWeatherPageState>{\n    render() {\n        console.log(\"Render!!\")\n        return (\n            <div>\n                <SearchBox style={{width: \"100%\"}}/>\n                <WeatherTableList weatherStateForecasts={this.props.weatherStateForecasts} />\n            </div>\n        );\n    }\n}\n\nfunction mapStateToProps(state: AppState) {\n    return {\n        location: state.locationSearch.selectedLocation,\n        displayTimes: state.forecasts.displayTimes,\n        weatherStateForecasts: state.forecasts.weatherStateForecasts,\n    }\n}\n\nfunction mapDispatchToProps(dispatch: any) { // TODO: Fix any type\n    return {\n        setDisplayTimes: (time: Date[]) => dispatch(setDisplayTimes(time)),\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(WeatherPage);","import React, { Dispatch } from 'react';\nimport './App.css';\nimport SearchBox from './components/atoms/SearchBox';\nimport WeatherPage from './components/pages/WeatherPage';\nimport Header from './components/organisms/Header';\n\nfunction App() {\n  return (\n    <div id=\"app\">\n      <div className=\"page\">\n        <WeatherPage />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { ILocationSearchState, LocationSearchActionTypes, SEARCH_START, SEARCH_SUCCESS, SEARCH_FAILURE, SELECT_LOCATION, UPDATE_USER_LOCATION } from './types';\n\nconst initialState: ILocationSearchState = {\n    selectedLocation: undefined,\n    searchResults: [],\n    isLoading: false,\n    errorMessage: '',\n    userLocation: undefined\n}\n\nexport function locationSearchReducer(state = initialState, action: LocationSearchActionTypes): ILocationSearchState {\n    switch (action.type) {\n        case UPDATE_USER_LOCATION:\n            return {\n                ...state,\n                userLocation: action.location\n            };\n        case SELECT_LOCATION:\n            return {\n                ...state,\n                selectedLocation: action.selectedLocation\n            };\n        case SEARCH_START:\n            return {\n                ...state,\n                isLoading: true\n            };\n        case SEARCH_SUCCESS:\n            return {\n                ...state,\n                isLoading: false,\n                searchResults: action.results,\n                errorMessage: \"\",\n            }\n        case SEARCH_FAILURE:\n            return {\n                ...state,\n                isLoading: false,\n                searchResults: [],\n                errorMessage: action.errorMessage\n            };\n        default:\n            return state;\n    }\n}","import { IWeatherState as IForecastState, ForecastActionTypes, FORECAST_FETCH_START, FORECAST_FETCH_SUCCESS, FORECAST_FETCH_FAILURE, SET_DISPLAY_TIMES, IWeatherStateForecast } from \"./types\";\nimport { listHoursFromNow } from \"../../helpers/date\";\nimport { getWeatherProviders } from \"../../weather\";\n\nconst initialState: IForecastState = {\n    weatherStateForecasts: createInitialForecasts(),\n    displayTimes: listHoursFromNow(24),\n    nothing: 1,\n}\n\nexport function forecastReducer(state = initialState, action: ForecastActionTypes): IForecastState {\n    switch (action.type) {\n        case FORECAST_FETCH_START:\n            console.log(\"Fetch start!!\")\n\n            var newWeatherStateForecasts: IWeatherStateForecast[] = JSON.parse(JSON.stringify(state.weatherStateForecasts));\n\n            var weatherStateForecast = newWeatherStateForecasts.find(element => element.weatherProvider.name === action.provider.name);\n            if (weatherStateForecast !== undefined) {\n                weatherStateForecast.loading = true;\n            }\n\n            return {\n                ...state,\n                weatherStateForecasts: newWeatherStateForecasts,\n            };\n\n        case FORECAST_FETCH_SUCCESS:\n            console.log(\"Fetch success!!\");\n\n            var newWeatherStateForecasts: IWeatherStateForecast[] = JSON.parse(JSON.stringify(state.weatherStateForecasts));\n\n            var weatherStateForecast = newWeatherStateForecasts.find(element => element.weatherProvider.name === action.provider.name);\n            if (weatherStateForecast !== undefined) {\n                weatherStateForecast.loading = false;\n                weatherStateForecast.forecast = action.forecast;\n            }\n\n            return {\n                ...state,\n                weatherStateForecasts: newWeatherStateForecasts,\n            };\n\n        case FORECAST_FETCH_FAILURE:\n            console.log(\"Fetch fail\")\n\n            // TODO: Implement\n\n            return { ...state }\n\n        case SET_DISPLAY_TIMES:\n            // TODO: remove?\n            return state;\n\n        default:\n            return state;\n    }\n}\n\nfunction createInitialForecasts(): IWeatherStateForecast[] {\n    let forecasts: IWeatherStateForecast[] = []\n    const providers = getWeatherProviders();\n\n    providers.forEach(provider => {\n        let forecast: IWeatherStateForecast = {\n            weatherProvider: provider,\n            loading: true,\n            forecast: {\n                weatherPoints: []\n            }\n        }\n        forecasts.push(forecast)\n    });\n\n    console.log(\"Initial forecasts:\", forecasts)\n\n    return forecasts;\n}\n","import { createStore, compose, combineReducers, applyMiddleware } from \"redux\";\nimport { locationSearchReducer } from \"./locationSearch/reducers\";\nimport thunk from 'redux-thunk';\nimport { forecastReducer } from \"./forecasts/reducers\";\n\nconst rootReducer = combineReducers({\n    locationSearch: locationSearchReducer,\n    forecasts: forecastReducer\n});\n\ndeclare global {\n    interface Window {\n        __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n    }\n}\n\nconst initialState = {}\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nexport default createStore(\n    rootReducer,\n    initialState,\n    compose(\n        applyMiddleware(thunk),\n        composeEnhancers()\n    )\n);\n\nexport type AppState = ReturnType<typeof rootReducer>\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport store from \"./store\";\nimport { Provider } from 'react-redux';\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}